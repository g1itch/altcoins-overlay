diff --git a/src/smessage.cpp b/src/smessage.cpp
index 449facb..da3aada 100644
--- a/src/smessage.cpp
+++ b/src/smessage.cpp
@@ -1,5 +1,5 @@
 // Copyright (c) 2014-2018 Fluttercoin Developers
-// Copyright (c) 2014 The ShadowCoin developers
+// Copyright (c) 2014-2015 The ShadowCoin developers
 // Copyright (c) 2014 The SilkCoin developers
 // Distributed under the MIT/X11 software license, see the accompanying
 // file COPYING or http://www.opensource.org/licenses/mit-license.php.
@@ -7,26 +7,25 @@
 /*
 Notes:
     Running with -debug could leave to and from address hashes and public keys in the log.
-    
-    
+
+
     parameters:
         -nosmsg             Disable secure messaging (fNoSmsg)
         -debugsmsg          Show extra debug messages (fDebugSmsg)
         -smsgscanchain      Scan the block chain for public key addresses on startup
-    
-    
+
+
     Wallet Locked
         A copy of each incoming message is stored in bucket files ending in _wl.dat
         wl (wallet locked) bucket files are deleted if they expire, like normal buckets
         When the wallet is unlocked all the messages in wl files are scanned.
-    
-    
+
+
     Address Whitelist
         Owned Addresses are stored in smsgAddresses vector
         Saved to smsg.ini
         Modify options using the smsglocalkeys rpc command or edit the smsg.ini file (with client closed)
-        
-    
+
 */
 
 #include "smessage.h"
@@ -97,79 +96,80 @@ leveldb::DB *smsgDB = NULL;
 
 namespace fs = boost::filesystem;
 
-bool SecMsgCrypter::SetKey(const std::vector<unsigned char>& vchNewKey, unsigned char* chNewIV)
+bool SecMsgCrypter::SetKey(const std::vector<uint8_t>& vchNewKey, uint8_t* chNewIV)
 {
-    
     if (vchNewKey.size() < sizeof(chKey))
         return false;
-    
+
     return SetKey(&vchNewKey[0], chNewIV);
 };
 
-bool SecMsgCrypter::SetKey(const unsigned char* chNewKey, unsigned char* chNewIV)
+bool SecMsgCrypter::SetKey(const uint8_t* chNewKey, uint8_t* chNewIV)
 {
     // -- for EVP_aes_256_cbc() key must be 256 bit, iv must be 128 bit.
     memcpy(&chKey[0], chNewKey, sizeof(chKey));
     memcpy(chIV, chNewIV, sizeof(chIV));
-    
+
     fKeySet = true;
     return true;
 };
 
-bool SecMsgCrypter::Encrypt(unsigned char* chPlaintext, uint32_t nPlain, std::vector<unsigned char> &vchCiphertext)
+bool SecMsgCrypter::Encrypt(uint8_t* chPlaintext, uint32_t nPlain, std::vector<uint8_t> &vchCiphertext)
 {
     if (!fKeySet)
         return false;
-    
+
     // -- max ciphertext len for a n bytes of plaintext is n + AES_BLOCK_SIZE - 1 bytes
     int nLen = nPlain;
-    
+
     int nCLen = nLen + AES_BLOCK_SIZE, nFLen = 0;
-    vchCiphertext = std::vector<unsigned char> (nCLen);
+    vchCiphertext = std::vector<uint8_t> (nCLen);
 
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_EncryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, &chKey[0], &chIV[0]);
-    if (fOk) fOk = EVP_EncryptUpdate(&ctx, &vchCiphertext[0], &nCLen, chPlaintext, nLen);
-    if (fOk) fOk = EVP_EncryptFinal_ex(&ctx, (&vchCiphertext[0])+nCLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_EncryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, &chKey[0], &chIV[0]);
+    if (fOk) fOk = EVP_EncryptUpdate(ctx, &vchCiphertext[0], &nCLen, chPlaintext, nLen);
+    if (fOk) fOk = EVP_EncryptFinal_ex(ctx, (&vchCiphertext[0])+nCLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk)
         return false;
 
     vchCiphertext.resize(nCLen + nFLen);
-    
+
     return true;
 };
 
-bool SecMsgCrypter::Decrypt(unsigned char* chCiphertext, uint32_t nCipher, std::vector<unsigned char>& vchPlaintext)
+bool SecMsgCrypter::Decrypt(uint8_t* chCiphertext, uint32_t nCipher, std::vector<uint8_t>& vchPlaintext)
 {
     if (!fKeySet)
         return false;
-    
+
     // plaintext will always be equal to or lesser than length of ciphertext
     int nPLen = nCipher, nFLen = 0;
-    
+
     vchPlaintext.resize(nCipher);
 
-    EVP_CIPHER_CTX ctx;
+    EVP_CIPHER_CTX *ctx = EVP_CIPHER_CTX_new();
 
     bool fOk = true;
 
-    EVP_CIPHER_CTX_init(&ctx);
-    if (fOk) fOk = EVP_DecryptInit_ex(&ctx, EVP_aes_256_cbc(), NULL, &chKey[0], &chIV[0]);
-    if (fOk) fOk = EVP_DecryptUpdate(&ctx, &vchPlaintext[0], &nPLen, &chCiphertext[0], nCipher);
-    if (fOk) fOk = EVP_DecryptFinal_ex(&ctx, (&vchPlaintext[0])+nPLen, &nFLen);
-    EVP_CIPHER_CTX_cleanup(&ctx);
+    EVP_CIPHER_CTX_init(ctx);
+    if (fOk) fOk = EVP_DecryptInit_ex(ctx, EVP_aes_256_cbc(), NULL, &chKey[0], &chIV[0]);
+    if (fOk) fOk = EVP_DecryptUpdate(ctx, &vchPlaintext[0], &nPLen, &chCiphertext[0], nCipher);
+    if (fOk) fOk = EVP_DecryptFinal_ex(ctx, (&vchPlaintext[0])+nPLen, &nFLen);
+    EVP_CIPHER_CTX_cleanup(ctx);
+    EVP_CIPHER_CTX_free(ctx);
 
     if (!fOk)
         return false;
-    
+
     vchPlaintext.resize(nPLen + nFLen);
-    
+
     return true;
 };
 
@@ -203,11 +203,11 @@ bool SecMsgDB::Open(const char* pszMode)
         pdb = smsgDB;
         return true;
     };
-    
+
     bool fCreate = strchr(pszMode, 'c');
-    
+
     fs::path fullpath = GetDataDir() / "smsgDB";
-    
+
     if (!fCreate
         && (!fs::exists(fullpath)
             || !fs::is_directory(fullpath)))
@@ -215,19 +215,19 @@ bool SecMsgDB::Open(const char* pszMode)
         printf("SecMsgDB::open() - DB does not exist.\n");
         return false;
     };
-    
+
     leveldb::Options options;
     options.create_if_missing = fCreate;
     leveldb::Status s = leveldb::DB::Open(options, fullpath.string(), &smsgDB);
-    
+
     if (!s.ok())
     {
         printf("SecMsgDB::open() - Error opening db: %s.\n", s.ToString().c_str());
         return false;
     };
-    
+
     pdb = smsgDB;
-    
+
     return true;
 };
 
@@ -239,9 +239,9 @@ public:
     bool* deleted;
     std::string* foundValue;
     bool foundEntry;
-    
+
     SecMsgBatchScanner() : foundEntry(false) {}
-    
+
     virtual void Put(const leveldb::Slice& key, const leveldb::Slice& value)
     {
         if (key.ToString() == needle)
@@ -251,7 +251,7 @@ public:
             *foundValue = value.ToString();
         };
     };
-    
+
     virtual void Delete(const leveldb::Slice& key)
     {
         if (key.ToString() == needle)
@@ -271,7 +271,7 @@ bool SecMsgDB::ScanBatch(const CDataStream& key, std::string* value, bool* delet
 {
     if (!activeBatch)
         return false;
-    
+
     *deleted = false;
     SecMsgBatchScanner scanner;
     scanner.needle = key.str();
@@ -283,7 +283,7 @@ bool SecMsgDB::ScanBatch(const CDataStream& key, std::string* value, bool* delet
         printf("SecMsgDB ScanBatch error: %s\n", s.ToString().c_str());
         return false;
     };
-    
+
     return scanner.foundEntry;
 }
 
@@ -299,19 +299,19 @@ bool SecMsgDB::TxnCommit()
 {
     if (!activeBatch)
         return false;
-    
+
     leveldb::WriteOptions writeOptions;
     writeOptions.sync = true;
     leveldb::Status status = pdb->Write(writeOptions, activeBatch);
     delete activeBatch;
     activeBatch = NULL;
-    
+
     if (!status.ok())
     {
         printf("SecMsgDB batch commit failure: %s\n", status.ToString().c_str());
         return false;
     };
-    
+
     return true;
 };
 
@@ -326,7 +326,7 @@ bool SecMsgDB::ReadPK(CKeyID& addr, CPubKey& pubkey)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.reserve(sizeof(addr) + 2);
     ssKey << 'p';
@@ -343,7 +343,7 @@ bool SecMsgDB::ReadPK(CKeyID& addr, CPubKey& pubkey)
         if (deleted)
             return false;
     };
-    
+
     if (readFromDb)
     {
         leveldb::Status s = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &strValue);
@@ -355,7 +355,7 @@ bool SecMsgDB::ReadPK(CKeyID& addr, CPubKey& pubkey)
             return false;
         };
     };
-    
+
     try {
         CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);
         ssValue >> pubkey;
@@ -363,7 +363,7 @@ bool SecMsgDB::ReadPK(CKeyID& addr, CPubKey& pubkey)
         printf("SecMsgDB::ReadPK() unserialize threw: %s.\n", e.what());
         return false;
     }
-    
+
     return true;
 };
 
@@ -371,7 +371,7 @@ bool SecMsgDB::WritePK(CKeyID& addr, CPubKey& pubkey)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.reserve(sizeof(addr) + 2);
     ssKey << 'p';
@@ -386,7 +386,7 @@ bool SecMsgDB::WritePK(CKeyID& addr, CPubKey& pubkey)
         activeBatch->Put(ssKey.str(), ssValue.str());
         return true;
     };
-    
+
     leveldb::WriteOptions writeOptions;
     writeOptions.sync = true;
     leveldb::Status s = pdb->Put(writeOptions, ssKey.str(), ssValue.str());
@@ -395,7 +395,7 @@ bool SecMsgDB::WritePK(CKeyID& addr, CPubKey& pubkey)
         printf("SecMsgDB write failure: %s\n", s.ToString().c_str());
         return false;
     };
-    
+
     return true;
 };
 
@@ -403,14 +403,14 @@ bool SecMsgDB::ExistsPK(CKeyID& addr)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.reserve(sizeof(addr)+2);
     ssKey << 'p';
     ssKey << 'k';
     ssKey << addr;
     std::string unused;
-    
+
     if (activeBatch)
     {
         bool deleted;
@@ -419,29 +419,29 @@ bool SecMsgDB::ExistsPK(CKeyID& addr)
             return true;
         };
     };
-    
+
     leveldb::Status s = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);
     return s.IsNotFound() == false;
 };
 
 
-bool SecMsgDB::NextSmesg(leveldb::Iterator* it, std::string& prefix, unsigned char* chKey, SecMsgStored& smsgStored)
+bool SecMsgDB::NextSmesg(leveldb::Iterator* it, std::string& prefix, uint8_t* chKey, SecMsgStored& smsgStored)
 {
     if (!pdb)
         return false;
-    
+
     if (!it->Valid()) // first run
         it->Seek(prefix);
     else
         it->Next();
-    
+
     if (!(it->Valid()
         && it->key().size() == 18
         && memcmp(it->key().data(), prefix.data(), 2) == 0))
         return false;
-    
+
     memcpy(chKey, it->key().data(), 18);
-    
+
     try {
         CDataStream ssValue(it->value().data(), it->value().data() + it->value().size(), SER_DISK, CLIENT_VERSION);
         ssValue >> smsgStored;
@@ -449,35 +449,35 @@ bool SecMsgDB::NextSmesg(leveldb::Iterator* it, std::string& prefix, unsigned ch
         printf("SecMsgDB::NextSmesg() unserialize threw: %s.\n", e.what());
         return false;
     }
-    
+
     return true;
 };
 
-bool SecMsgDB::NextSmesgKey(leveldb::Iterator* it, std::string& prefix, unsigned char* chKey)
+bool SecMsgDB::NextSmesgKey(leveldb::Iterator* it, std::string& prefix, uint8_t* chKey)
 {
     if (!pdb)
         return false;
-    
+
     if (!it->Valid()) // first run
         it->Seek(prefix);
     else
         it->Next();
-    
+
     if (!(it->Valid()
         && it->key().size() == 18
         && memcmp(it->key().data(), prefix.data(), 2) == 0))
         return false;
-    
+
     memcpy(chKey, it->key().data(), 18);
-    
+
     return true;
 };
 
-bool SecMsgDB::ReadSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
+bool SecMsgDB::ReadSmesg(uint8_t* chKey, SecMsgStored& smsgStored)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.write((const char*)chKey, 18);
     std::string strValue;
@@ -491,7 +491,7 @@ bool SecMsgDB::ReadSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
         if (deleted)
             return false;
     };
-    
+
     if (readFromDb)
     {
         leveldb::Status s = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &strValue);
@@ -503,7 +503,7 @@ bool SecMsgDB::ReadSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
             return false;
         };
     };
-    
+
     try {
         CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);
         ssValue >> smsgStored;
@@ -511,15 +511,15 @@ bool SecMsgDB::ReadSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
         printf("SecMsgDB::ReadSmesg() unserialize threw: %s.\n", e.what());
         return false;
     }
-    
+
     return true;
 };
 
-bool SecMsgDB::WriteSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
+bool SecMsgDB::WriteSmesg(uint8_t* chKey, SecMsgStored& smsgStored)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.write((const char*)chKey, 18);
     CDataStream ssValue(SER_DISK, CLIENT_VERSION);
@@ -530,7 +530,7 @@ bool SecMsgDB::WriteSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
         activeBatch->Put(ssKey.str(), ssValue.str());
         return true;
     };
-    
+
     leveldb::WriteOptions writeOptions;
     writeOptions.sync = true;
     leveldb::Status s = pdb->Put(writeOptions, ssKey.str(), ssValue.str());
@@ -539,19 +539,19 @@ bool SecMsgDB::WriteSmesg(unsigned char* chKey, SecMsgStored& smsgStored)
         printf("SecMsgDB write failed: %s\n", s.ToString().c_str());
         return false;
     };
-    
+
     return true;
 };
 
-bool SecMsgDB::ExistsSmesg(unsigned char* chKey)
+bool SecMsgDB::ExistsSmesg(uint8_t* chKey)
 {
     if (!pdb)
         return false;
-    
+
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.write((const char*)chKey, 18);
     std::string unused;
-    
+
     if (activeBatch)
     {
         bool deleted;
@@ -560,27 +560,27 @@ bool SecMsgDB::ExistsSmesg(unsigned char* chKey)
             return true;
         };
     };
-    
+
     leveldb::Status s = pdb->Get(leveldb::ReadOptions(), ssKey.str(), &unused);
     return s.IsNotFound() == false;
     return true;
 };
 
-bool SecMsgDB::EraseSmesg(unsigned char* chKey)
+bool SecMsgDB::EraseSmesg(uint8_t* chKey)
 {
     CDataStream ssKey(SER_DISK, CLIENT_VERSION);
     ssKey.write((const char*)chKey, 18);
-    
+
     if (activeBatch)
     {
         activeBatch->Delete(ssKey.str());
         return true;
     };
-    
+
     leveldb::WriteOptions writeOptions;
     writeOptions.sync = true;
     leveldb::Status s = pdb->Delete(writeOptions, ssKey.str());
-    
+
     if (s.ok() || s.IsNotFound())
         return true;
     printf("SecMsgDB erase failed: %s\n", s.ToString().c_str());
@@ -611,9 +611,8 @@ void ThreadSecureMsg(void* parg)
         
         if (fDebugSmsg)
             printf("SecureMsgThread %" PRI64d" \n", now);
-        
+
         int64_t cutoffTime = now - SMSG_RETENTION;
-        
         {
             LOCK(cs_smsg);
             std::map<int64_t, SecMsgBucket>::iterator it;
@@ -631,8 +630,7 @@ void ThreadSecureMsg(void* parg)
                     fs::path fullPath = GetDataDir() / "smsgStore" / fileName;
                     if (fs::exists(fullPath))
                     {
-                        try {
-                            fs::remove(fullPath);
+                        try { fs::remove(fullPath);
                         } catch (const fs::filesystem_error& ex)
                         {
                             printf("Error removing bucket file %s.\n", ex.what());
@@ -645,14 +643,13 @@ void ThreadSecureMsg(void* parg)
                     fullPath = GetDataDir() / "smsgStore" / fileName;
                     if (fs::exists(fullPath))
                     {
-                        try {
-                            fs::remove(fullPath);
+                        try { fs::remove(fullPath);
                         } catch (const fs::filesystem_error& ex)
                         {
                             printf("Error removing wallet locked file %s.\n", ex.what());
                         };
                     };
-                    
+
                     smsgBuckets.erase(it++);
                 } else
                 {
@@ -665,7 +662,7 @@ void ThreadSecureMsg(void* parg)
                         {
                             uint32_t    nPeerId     = it->second.nLockPeerId;
                             int64_t     ignoreUntil = GetTime() + SMSG_TIME_IGNORE;
-                            
+
                             if (fDebugSmsg)
                                 printf("Lock on bucket %" PRI64d" for peer %u timed out.\n", it->first, nPeerId);
                             // -- look through the nodes for the peer that locked this bucket
@@ -675,9 +672,9 @@ void ThreadSecureMsg(void* parg)
                                 if (pnode->smsgData.nPeerId != nPeerId)
                                     continue;
                                 pnode->smsgData.ignoreUntil = ignoreUntil;
-                                
+
                                 // -- alert peer that they are being ignored
-                                std::vector<unsigned char> vchData;
+                                std::vector<uint8_t> vchData;
                                 vchData.resize(8);
                                 memcpy(&vchData[0], &ignoreUntil, 8);
                                 pnode->PushMessage("smsgIgnore", vchData);
@@ -694,7 +691,7 @@ void ThreadSecureMsg(void* parg)
             };
         }; // LOCK(cs_smsg);
     };
-    
+
     printf("ThreadSecureMsg exited.\n");
 };
 
@@ -702,49 +699,49 @@ void ThreadSecureMsgPow(void* parg)
 {
     // -- proof of work thread
     RenameThread("silkcoin-smsg-pow"); // Make this thread recognisable
-    
+
     int rv;
-    std::vector<unsigned char> vchKey;
+    std::vector<uint8_t> vchKey;
     SecMsgStored smsgStored;
-    
+
     std::string sPrefix("qm");
-    unsigned char chKey[18];
-    
-    
+    uint8_t chKey[18];
+
+
     while (fSecMsgEnabled)
     {
         // -- sleep at end, then fSecMsgEnabled is tested on wake
-        
+
         SecMsgDB dbOutbox;
         leveldb::Iterator* it;
         {
             LOCK(cs_smsgDB);
-            
+
             if (!dbOutbox.Open("cr+"))
                 continue;
-            
+
             // -- fifo (smallest key first)
             it = dbOutbox.pdb->NewIterator(leveldb::ReadOptions());
         }
         // -- break up lock, SecureMsgSetHash will take long
-        
+
         for (;;)
         {
             {
-                LOCK(cs_smsgDB); 
+                LOCK(cs_smsgDB);
                 if (!dbOutbox.NextSmesg(it, sPrefix, chKey, smsgStored))
                     break;
             }
-            
-            unsigned char* pHeader = &smsgStored.vchMessage[0];
-            unsigned char* pPayload = &smsgStored.vchMessage[SMSG_HDR_LEN];
+
+            uint8_t* pHeader = &smsgStored.vchMessage[0];
+            uint8_t* pPayload = &smsgStored.vchMessage[SMSG_HDR_LEN];
             SecureMessage* psmsg = (SecureMessage*) pHeader;
-            
+
             // -- do proof of work
             rv = SecureMsgSetHash(pHeader, pPayload, psmsg->nPayload);
-            if (rv == 2) 
-                break; // /eave message in db, if terminated due to shutdown
-            
+            if (rv == 2)
+                break; // leave message in db, if terminated due to shutdown
+
             // -- message is removed here, no matter what
             {
                 LOCK(cs_smsgDB);
@@ -755,7 +752,7 @@ void ThreadSecureMsgPow(void* parg)
                 printf("SecMsgPow: Could not get proof of work hash, message removed.\n");
                 continue;
             };
-            
+
             // -- add to message store
             {
                 LOCK(cs_smsg);
@@ -765,23 +762,23 @@ void ThreadSecureMsgPow(void* parg)
                     continue;
                 };
             }
-            
+
             // -- test if message was sent to self
             if (SecureMsgScanMessage(pHeader, pPayload, psmsg->nPayload, true) != 0)
             {
                 // message recipient is not this node (or failed)
             };
         };
-        
+
         {
             LOCK(cs_smsg);
             delete it;
         }
-        
+
         // -- shutdown thread waits 5 seconds, this should be less
         MilliSleep(1000); // milliseconds
     };
-    
+
     printf("ThreadSecureMsgPow exited.\n");
 };
 
@@ -819,57 +816,57 @@ int SecureMsgBuildBucketSet()
 {
     /*
         Build the bucket set by scanning the files in the smsgStore dir.
-        
+
         smsgBuckets should be empty
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgBuildBucketSet()\n");
-        
+
     int64_t  now            = GetTime();
     uint32_t nFiles         = 0;
     uint32_t nMessages      = 0;
-    
+
     fs::path pathSmsgDir = GetDataDir() / "smsgStore";
     fs::directory_iterator itend;
-    
-    
+
+
     if (!fs::exists(pathSmsgDir)
         || !fs::is_directory(pathSmsgDir))
     {
         printf("Message store directory does not exist.\n");
         return 0; // not an error
     }
-    
-    
+
+
     for (fs::directory_iterator itd(pathSmsgDir) ; itd != itend ; ++itd)
     {
         if (!fs::is_regular_file(itd->status()))
             continue;
-        
+
         std::string fileType = (*itd).path().extension().string();
-        
+
         if (fileType.compare(".dat") != 0)
             continue;
-            
+
         std::string fileName = (*itd).path().filename().string();
-        
-        
+
+
         if (fDebugSmsg)
             printf("Processing file: %s.\n", fileName.c_str());
-        
+
         nFiles++;
-        
+
         // TODO files must be split if > 2GB
         // time_noFile.dat
         size_t sep = fileName.find_first_of("_");
         if (sep == std::string::npos)
             continue;
-        
+
         std::string stime = fileName.substr(0, sep);
-        
+
         int64_t fileTime = boost::lexical_cast<int64_t>(stime);
-        
+
         if (fileTime < now - SMSG_RETENTION)
         {
             printf("Dropping file %s, expired.\n", fileName.c_str());
@@ -881,35 +878,36 @@ int SecureMsgBuildBucketSet()
             };
             continue;
         };
-        
+
         if (boost::algorithm::ends_with(fileName, "_wl.dat"))
         {
             if (fDebugSmsg)
                 printf("Skipping wallet locked file: %s.\n", fileName.c_str());
             continue;
         };
-        
-        
+
+        size_t nTokenSetSize = 0;
         SecureMessage smsg;
-        std::set<SecMsgToken>& tokenSet = smsgBuckets[fileTime].setTokens;
-        
         {
             LOCK(cs_smsg);
-            FILE *fp;
             
+            std::set<SecMsgToken>& tokenSet = smsgBuckets[fileTime].setTokens;
+            
+            FILE *fp;
+
             if (!(fp = fopen((*itd).path().string().c_str(), "rb")))
             {
                 printf("Error opening file: %s\n", strerror(errno));
                 continue;
             };
-            
+
             for (;;)
             {
                 long int ofs = ftell(fp);
                 SecMsgToken token;
                 token.offset = ofs;
                 errno = 0;
-                if (fread(&smsg.hash[0], sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
+                if (fread(&smsg.hash[0], sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
                 {
                     if (errno != 0)
                     {
@@ -921,37 +919,39 @@ int SecureMsgBuildBucketSet()
                     break;
                 };
                 token.timestamp = smsg.timestamp;
-                
+
                 if (smsg.nPayload < 8)
                     continue;
-                
-                if (fread(token.sample, sizeof(unsigned char), 8, fp) != 8)
+
+                if (fread(token.sample, sizeof(uint8_t), 8, fp) != 8)
                 {
                     printf("fread data failed: %s\n", strerror(errno));
                     break;
                 };
-                
+
                 if (fseek(fp, smsg.nPayload-8, SEEK_CUR) != 0)
                 {
                     printf("fseek, strerror: %s.\n", strerror(errno));
                     break;
                 };
-                
+
                 tokenSet.insert(token);
             };
-            
+
             fclose(fp);
+
+	    smsgBuckets[fileTime].hashBucket();
+
+	    nTokenSetSize = tokenSet.size();
         };
-        smsgBuckets[fileTime].hashBucket();
-        
-        nMessages += tokenSet.size();
-        
+
+        nMessages += nTokenSetSize;
         if (fDebugSmsg)
-            printf("Bucket %" PRI64d" contains %" PRIszu" messages.\n", fileTime, tokenSet.size());
+            printf("Bucket %" PRI64d" contains %" PRIszu" messages.\n", fileTime, nTokenSetSize);
     };
-    
+
     printf("Processed %u files, loaded %" PRIszu" buckets containing %u messages.\n", nFiles, smsgBuckets.size(), nMessages);
-    
+
     return 0;
 };
 
@@ -959,22 +959,21 @@ int SecureMsgAddWalletAddresses()
 {
     if (fDebugSmsg)
         printf("SecureMsgAddWalletAddresses()\n");
-    
+
     uint32_t nAdded = 0;
     BOOST_FOREACH(const PAIRTYPE(CTxDestination, std::string)& entry, pwalletMain->mapAddressBook)
     {
         if (!IsMine(*pwalletMain, entry.first))
             continue;
-        
+
         CBitcoinAddress coinAddress(entry.first);
         if (!coinAddress.IsValid())
             continue;
-        
+
         std::string address;
         std::string strPublicKey;
         address = coinAddress.ToString();
-        
-        
+
         bool fExists        = 0;
         for (std::vector<SecMsgAddress>::iterator it = smsgAddresses.begin(); it != smsgAddresses.end(); ++it)
         {
@@ -983,20 +982,20 @@ int SecureMsgAddWalletAddresses()
             fExists = 1;
             break;
         };
-        
+
         if (fExists)
             continue;
-        
+
         bool recvEnabled    = 1;
         bool recvAnon       = 1;
-        
+
         smsgAddresses.push_back(SecMsgAddress(address, recvEnabled, recvAnon));
         nAdded++;
     };
-    
+
     if (fDebugSmsg)
         printf("Added %u addresses to whitelist.\n", nAdded);
-    
+
     return 0;
 };
 
@@ -1005,13 +1004,13 @@ int SecureMsgReadIni()
 {
     if (!fSecMsgEnabled)
         return false;
-    
+
     if (fDebugSmsg)
         printf("SecureMsgReadIni()\n");
-    
+
     fs::path fullpath = GetDataDir() / "smsg.ini";
-    
-    
+
+
     FILE *fp;
     errno = 0;
     if (!(fp = fopen(fullpath.string().c_str(), "r")))
@@ -1019,27 +1018,27 @@ int SecureMsgReadIni()
         printf("Error opening file: %s\n", strerror(errno));
         return 1;
     };
-    
+
     char cLine[512];
     char *pName, *pValue;
-    
+
     char cAddress[64];
     int addrRecv, addrRecvAnon;
-    
+
     while (fgets(cLine, 512, fp))
     {
         cLine[strcspn(cLine, "\n")] = '\0';
         cLine[strcspn(cLine, "\r")] = '\0';
         cLine[511] = '\0'; // for safety
-        
+
         // -- check that line contains a name value pair and is not a comment, or section header
         if (cLine[0] == '#' || cLine[0] == '[' || strcspn(cLine, "=") < 1)
             continue;
-        
+
         if (!(pName = strtok(cLine, "="))
             || !(pValue = strtok(NULL, "=")))
             continue;
-        
+
         if (strcmp(pName, "newAddressRecv") == 0)
         {
             smsgOptions.fNewAddressRecv = (strcmp(pValue, "true") == 0) ? true : false;
@@ -1063,11 +1062,11 @@ int SecureMsgReadIni()
             printf("Unknown setting name: '%s'.", pName);
         };
     };
-    
+
     printf("Loaded %" PRIszu" addresses.\n", smsgAddresses.size());
-    
+
     fclose(fp);
-    
+
     return 0;
 };
 
@@ -1075,12 +1074,12 @@ int SecureMsgWriteIni()
 {
     if (!fSecMsgEnabled)
         return false;
-    
+
     if (fDebugSmsg)
         printf("SecureMsgWriteIni()\n");
-    
+
     fs::path fullpath = GetDataDir() / "smsg.ini~";
-    
+
     FILE *fp;
     errno = 0;
     if (!(fp = fopen(fullpath.string().c_str(), "w")))
@@ -1088,14 +1087,14 @@ int SecureMsgWriteIni()
         printf("Error opening file: %s\n", strerror(errno));
         return 1;
     };
-    
+
     if (fwrite("[Options]\n", sizeof(char), 10, fp) != 10)
     {
         printf("fwrite error: %s\n", strerror(errno));
         fclose(fp);
         return false;
     };
-    
+
     if (fprintf(fp, "newAddressRecv=%s\n", smsgOptions.fNewAddressRecv ? "true" : "false") < 0
         || fprintf(fp, "newAddressAnon=%s\n", smsgOptions.fNewAddressAnon ? "true" : "false") < 0)
     {
@@ -1103,7 +1102,7 @@ int SecureMsgWriteIni()
         fclose(fp);
         return false;
     }
-    
+
     if (fwrite("\n[Keys]\n", sizeof(char), 8, fp) != 8)
     {
         printf("fwrite error: %s\n", strerror(errno));
@@ -1119,11 +1118,11 @@ int SecureMsgWriteIni()
             continue;
         };
     };
-    
-    
+
+
     fclose(fp);
-    
-    
+
+
     try {
         fs::path finalpath = GetDataDir() / "smsg.ini";
         fs::rename(fullpath, finalpath);
@@ -1143,33 +1142,33 @@ bool SecureMsgStart(bool fDontStart, bool fScanChain)
         printf("Secure messaging not started.\n");
         return false;
     };
-    
+
     printf("Secure messaging starting.\n");
-    
+
     fSecMsgEnabled = true;
-    
+
     if (SecureMsgReadIni() != 0)
         printf("Failed to read smsg.ini\n");
-    
+
     if (smsgAddresses.size() < 1)
     {
         printf("No address keys loaded.\n");
         if (SecureMsgAddWalletAddresses() != 0)
             printf("Failed to load addresses from wallet.\n");
     };
-    
+
     if (fScanChain)
     {
         SecureMsgScanBlockChain();
     };
-    
+
     if (SecureMsgBuildBucketSet() != 0)
     {
         printf("SecureMsg could not load bucket sets, secure messaging disabled.\n");
         fSecMsgEnabled = false;
         return false;
     };
-    
+
     // -- start threads
     if (!NewThread(ThreadSecureMsg, NULL)
         || !NewThread(ThreadSecureMsgPow, NULL))
@@ -1178,7 +1177,7 @@ bool SecureMsgStart(bool fDontStart, bool fScanChain)
         fSecMsgEnabled = false;
         return false;
     };
-    
+
     return true;
 };
 
@@ -1187,24 +1186,23 @@ bool SecureMsgShutdown()
 {
     if (!fSecMsgEnabled)
         return false;
-    
+
     printf("Stopping secure messaging.\n");
-    
-    
+
+
     if (SecureMsgWriteIni() != 0)
         printf("Failed to save smsg.ini\n");
-    
+
     fSecMsgEnabled = false;
-    
+
     if (smsgDB)
     {
         LOCK(cs_smsgDB);
         delete smsgDB;
         smsgDB = NULL;
     };
-    
+
     // -- main program will wait 5 seconds for threads to terminate.
-    
     return true;
 };
 
@@ -1216,33 +1214,33 @@ bool SecureMsgEnable()
         printf("SecureMsgEnable: secure messaging is already enabled.\n");
         return false;
     };
-    
+
     {
         LOCK(cs_smsg);
         fSecMsgEnabled = true;
-        
+
         smsgAddresses.clear(); // should be empty already
         if (SecureMsgReadIni() != 0)
             printf("Failed to read smsg.ini\n");
-        
+
         if (smsgAddresses.size() < 1)
         {
             printf("No address keys loaded.\n");
             if (SecureMsgAddWalletAddresses() != 0)
                 printf("Failed to load addresses from wallet.\n");
         };
-        
+
         smsgBuckets.clear(); // should be empty already
-        
+
         if (SecureMsgBuildBucketSet() != 0)
         {
             printf("SecureMsgEnable: could not load bucket sets, secure messaging disabled.\n");
             fSecMsgEnabled = false;
             return false;
         };
-        
+
     }; // LOCK(cs_smsg);
-    
+
     // -- start threads
     if (!NewThread(ThreadSecureMsg, NULL)
         || !NewThread(ThreadSecureMsgPow, NULL))
@@ -1251,7 +1249,7 @@ bool SecureMsgEnable()
         fSecMsgEnabled = false;
         return false;
     };
-    
+
     // -- ping each peer, don't know which have messaging enabled
     {
         LOCK(cs_vNodes);
@@ -1261,7 +1259,7 @@ bool SecureMsgEnable()
             pnode->PushMessage("smsgPong"); // Send pong as have missed initial ping sent by peer when it connected
         };
     }
-    
+
     printf("Secure messaging enabled.\n");
     return true;
 };
@@ -1274,11 +1272,11 @@ bool SecureMsgDisable()
         printf("SecureMsgDisable: secure messaging is already disabled.\n");
         return false;
     };
-    
+
     {
         LOCK(cs_smsg);
         fSecMsgEnabled = false;
-        
+
         // -- clear smsgBuckets
         std::map<int64_t, SecMsgBucket>::iterator it;
         it = smsgBuckets.begin();
@@ -1287,7 +1285,7 @@ bool SecureMsgDisable()
             it->second.setTokens.clear();
         };
         smsgBuckets.clear();
-        
+
         // -- tell each smsg enabled peer that this node is disabling
         {
             LOCK(cs_vNodes);
@@ -1300,26 +1298,26 @@ bool SecureMsgDisable()
                 pnode->smsgData.fEnabled = false;
             };
         }
-    
+
         if (SecureMsgWriteIni() != 0)
             printf("Failed to save smsg.ini\n");
-        
+
         smsgAddresses.clear();
         
     }; // LOCK(cs_smsg);
-    
+
     // -- allow time for threads to stop
     MilliSleep(3000); // milliseconds
     // TODO be certain that threads have stopped
-    
+
     if (smsgDB)
     {
         LOCK(cs_smsgDB);
         delete smsgDB;
         smsgDB = NULL;
     };
-    
-    
+
+
     printf("Secure messaging disabled.\n");
     return true;
 };
@@ -1331,42 +1329,42 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
         Called from ProcessMessage
         Runs in ThreadMessageHandler2
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgReceiveData() %s %s.\n", pfrom->addrName.c_str(), strCommand.c_str());
-    
+
     {
     // break up?
     LOCK(cs_smsg);
-    
+
     if (strCommand == "smsgInv")
     {
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (vchData.size() < 4)
         {
             pfrom->Misbehaving(1);
             return false; // not enough data received to be a valid smsgInv
         };
-        
+
         int64_t now = GetTime();
-        
+
         if (now < pfrom->smsgData.ignoreUntil)
         {
             if (fDebugSmsg)
                 printf("Node is ignoring peer %u until %" PRI64d".\n", pfrom->smsgData.nPeerId, pfrom->smsgData.ignoreUntil);
             return false;
         };
-        
+
         uint32_t nBuckets       = smsgBuckets.size();
         uint32_t nLocked        = 0;    // no. of locked buckets on this node
         uint32_t nInvBuckets;           // no. of bucket headers sent by peer in smsgInv
         memcpy(&nInvBuckets, &vchData[0], 4);
         if (fDebugSmsg)
             printf("Remote node sent %d bucket headers, this has %d.\n", nInvBuckets, nBuckets);
-        
-        
+
+
         // -- Check no of buckets:
         if (nInvBuckets > (SMSG_RETENTION / SMSG_BUCKET_LEN) + 1) // +1 for some leeway
         {
@@ -1374,21 +1372,21 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             pfrom->Misbehaving(1);
             return false;
         };
-        
+
         if (vchData.size() < 4 + nInvBuckets*16)
         {
             printf("Remote node did not send enough data.\n");
             pfrom->Misbehaving(1);
             return false;
         };
-        
-        std::vector<unsigned char> vchDataOut;
+
+        std::vector<uint8_t> vchDataOut;
         vchDataOut.reserve(4 + 8 * nInvBuckets); // reserve max possible size
         vchDataOut.resize(4);
         uint32_t nShowBuckets = 0;
-        
-        
-        unsigned char *p = &vchData[4];
+
+
+        uint8_t *p = &vchData[4];
         for (uint32_t i = 0; i < nInvBuckets; ++i)
         {
             int64_t time;
@@ -1396,15 +1394,15 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             memcpy(&time, p, 8);
             memcpy(&ncontent, p+8, 4);
             memcpy(&hash, p+12, 4);
-            
+
             p += 16;
-            
+
             // Check time valid:
             if (time < now - SMSG_RETENTION)
             {
                 if (fDebugSmsg)
                     printf("Not interested in peer bucket %" PRI64d", has expired.\n", time);
-                
+
                 if (time < now - SMSG_RETENTION - SMSG_TIME_LEEWAY)
                     pfrom->Misbehaving(1);
                 continue;
@@ -1416,20 +1414,20 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 pfrom->Misbehaving(1);
                 continue;
             };
-            
+
             if (ncontent < 1)
             {
                 if (fDebugSmsg)
                     printf("Peer sent empty bucket, ignore %" PRI64d" %u %u.\n", time, ncontent, hash);
                 continue;
             };
-            
+
             if (fDebugSmsg)
             {
                 printf("peer bucket %" PRI64d" %u %u.\n", time, ncontent, hash);
                 printf("this bucket %" PRI64d" %" PRIszu" %u.\n", time, smsgBuckets[time].setTokens.size(), smsgBuckets[time].hash);
             };
-            
+
             if (smsgBuckets[time].nLockCount > 0)
             {
                 if (fDebugSmsg)
@@ -1437,7 +1435,7 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 nLocked++;
                 continue;
             };
-            
+
             // -- if this node has more than the peer node, peer node will pull from this
             //    if then peer node has more this node will pull fom peer
             if (smsgBuckets[time].setTokens.size() < ncontent
@@ -1446,15 +1444,15 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             {
                 if (fDebugSmsg)
                     printf("Requesting contents of bucket %" PRI64d".\n", time);
-                
+
                 uint32_t sz = vchDataOut.size();
                 vchDataOut.resize(sz + 8);
                 memcpy(&vchDataOut[sz], &time, 8);
-                
+
                 nShowBuckets++;
             };
         };
-        
+
         // TODO: should include hash?
         memcpy(&vchDataOut[0], &nShowBuckets, 4);
         if (vchDataOut.size() > 4)
@@ -1471,35 +1469,35 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             if (fDebugSmsg)
                 printf("Sending smsgMatch, %" PRI64d".\n", now);
         };
-        
+
     } else
     if (strCommand == "smsgShow")
     {
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (vchData.size() < 4)
             return false;
-        
+
         uint32_t nBuckets;
         memcpy(&nBuckets, &vchData[0], 4);
-        
+
         if (vchData.size() < 4 + nBuckets * 8)
             return false;
-        
+
         if (fDebugSmsg)
             printf("smsgShow: peer wants to see content of %u buckets.\n", nBuckets);
-        
+
         std::map<int64_t, SecMsgBucket>::iterator itb;
         std::set<SecMsgToken>::iterator it;
-        
-        std::vector<unsigned char> vchDataOut;
+
+        std::vector<uint8_t> vchDataOut;
         int64_t time;
-        unsigned char* pIn = &vchData[4];
+        uint8_t* pIn = &vchData[4];
         for (uint32_t i = 0; i < nBuckets; ++i, pIn += 8)
         {
             memcpy(&time, pIn, 8);
-            
+
             itb = smsgBuckets.find(time);
             if (itb == smsgBuckets.end())
             {
@@ -1507,9 +1505,9 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                     printf("Don't have bucket %" PRI64d".\n", time);
                 continue;
             };
-            
+
             std::set<SecMsgToken>& tokenSet = (*itb).second.setTokens;
-            
+
             try {
                 vchDataOut.resize(8 + 16 * tokenSet.size());
             } catch (std::exception& e) {
@@ -1517,8 +1515,8 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 continue;
             };
             memcpy(&vchDataOut[0], &time, 8);
-            
-            unsigned char* p = &vchDataOut[8];
+
+            uint8_t* p = &vchDataOut[8];
             for (it = tokenSet.begin(); it != tokenSet.end(); ++it)
             {
                 memcpy(p, &it->timestamp, 8);
@@ -1528,23 +1526,23 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             };
             pfrom->PushMessage("smsgHave", vchDataOut);
         };
-        
-        
+
+
     } else
     if (strCommand == "smsgHave")
     {
         // -- peer has these messages in bucket
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (vchData.size() < 8)
             return false;
-        
+
         int n = (vchData.size() - 8) / 16;
-        
+
         int64_t time;
         memcpy(&time, &vchData[0], 8);
-        
+
         // -- Check time valid:
         int64_t now = GetTime();
         if (time < now - SMSG_RETENTION)
@@ -1560,31 +1558,31 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             pfrom->Misbehaving(1);
             return false;
         };
-        
+
         if (smsgBuckets[time].nLockCount > 0)
         {
             if (fDebugSmsg)
                 printf("Bucket %" PRI64d" lock count %u, waiting for message data from peer %u.\n", time, smsgBuckets[time].nLockCount, smsgBuckets[time].nLockPeerId);
             return false;
         }; 
-        
+
         if (fDebugSmsg)
             printf("Sifting through bucket %" PRI64d".\n", time);
-        
-        std::vector<unsigned char> vchDataOut;
+
+        std::vector<uint8_t> vchDataOut;
         vchDataOut.resize(8);
         memcpy(&vchDataOut[0], &vchData[0], 8);
-        
+
         std::set<SecMsgToken>& tokenSet = smsgBuckets[time].setTokens;
         std::set<SecMsgToken>::iterator it;
         SecMsgToken token;
-        unsigned char* p = &vchData[8];
-        
+        uint8_t* p = &vchData[8];
+
         for (int i = 0; i < n; ++i)
         {
             memcpy(&token.timestamp, p, 8);
             memcpy(&token.sample, p+8, 8);
-            
+
             it = tokenSet.find(token);
             if (it == tokenSet.end())
             {
@@ -1595,13 +1593,13 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                     printf("vchDataOut.resize %d threw: %s.\n", nd + 16, e.what());
                     continue;
                 };
-                
+
                 memcpy(&vchDataOut[nd], p, 16);
             };
-            
+
             p += 16;
         };
-        
+
         if (vchDataOut.size() > 8)
         {
             if (fDebugSmsg)
@@ -1616,23 +1614,23 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
     } else
     if (strCommand == "smsgWant")
     {
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (vchData.size() < 8)
             return false;
-        
-        std::vector<unsigned char> vchOne;
-        std::vector<unsigned char> vchBunch;
-        
+
+        std::vector<uint8_t> vchOne;
+        std::vector<uint8_t> vchBunch;
+
         vchBunch.resize(4+8); // nmessages + bucketTime
-        
+
         int n = (vchData.size() - 8) / 16;
-        
+
         int64_t time;
         uint32_t nBunch = 0;
         memcpy(&time, &vchData[0], 8);
-        
+
         std::map<int64_t, SecMsgBucket>::iterator itb;
         itb = smsgBuckets.find(time);
         if (itb == smsgBuckets.end())
@@ -1641,16 +1639,16 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 printf("Don't have bucket %" PRI64d".\n", time);
             return false;
         };
-        
+
         std::set<SecMsgToken>& tokenSet = itb->second.setTokens;
         std::set<SecMsgToken>::iterator it;
         SecMsgToken token;
-        unsigned char* p = &vchData[8];
+        uint8_t* p = &vchData[8];
         for (int i = 0; i < n; ++i)
         {
             memcpy(&token.timestamp, p, 8);
             memcpy(&token.sample, p+8, 8);
-            
+
             it = tokenSet.find(token);
             if (it == tokenSet.end())
             {
@@ -1661,7 +1659,7 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 //printf("Have message at %" PRI64d".\n", it->offset); // DEBUG
                 token.offset = it->offset;
                 //printf("winb before SecureMsgRetrieve %" PRI64d".\n", token.timestamp);
-                
+
                 // -- place in vchOne so if SecureMsgRetrieve fails it won't corrupt vchBunch
                 if (SecureMsgRetrieve(token, vchOne) == 0)
                 {
@@ -1682,12 +1680,12 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
             };
             p += 16;
         };
-        
+
         if (nBunch > 0)
         {
             if (fDebugSmsg)
                 printf("Sending block of %u messages for bucket %" PRI64d".\n", nBunch, time);
-            
+
             memcpy(&vchBunch[0], &nBunch, 4);
             memcpy(&vchBunch[4], &time, 8);
             pfrom->PushMessage("smsgMsg", vchBunch);
@@ -1695,30 +1693,30 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
     } else
     if (strCommand == "smsgMsg")
     {
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (fDebugSmsg)
             printf("smsgMsg vchData.size() %" PRIszu".\n", vchData.size());
-        
+
         SecureMsgReceive(pfrom, vchData);
     } else
     if (strCommand == "smsgMatch")
     {
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
-        
+
+
         if (vchData.size() < 8)
         {
             printf("smsgMatch, not enough data %" PRIszu".\n", vchData.size());
             pfrom->Misbehaving(1);
             return false;
         };
-        
+
         int64_t time;
         memcpy(&time, &vchData[0], 8);
-        
+
         int64_t now = GetTime();
         if (time > now + SMSG_TIME_LEEWAY)
         {
@@ -1727,12 +1725,12 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
                 printf("Peer match time set to now.\n");
             time = now;
         };
-        
+
         pfrom->smsgData.lastMatched = time;
-        
+
         if (fDebugSmsg)
             printf("Peer buckets matched at %" PRI64d".\n", time);
-        
+
     } else
     if (strCommand == "smsgPing")
     {
@@ -1743,47 +1741,47 @@ bool SecureMsgReceiveData(CNode* pfrom, std::string strCommand, CDataStream& vRe
     {
         if (fDebugSmsg)
              printf("Peer replied, secure messaging enabled.\n");
-        
+
         pfrom->smsgData.fEnabled = true;
     } else
     if (strCommand == "smsgDisabled")
     {
         // -- peer has disabled secure messaging.
-        
+
         pfrom->smsgData.fEnabled = false;
-        
+
         if (fDebugSmsg)
             printf("Peer %u has disabled secure messaging.\n", pfrom->smsgData.nPeerId);
-        
+
     } else
     if (strCommand == "smsgIgnore")
     {
         // -- peer is reporting that it will ignore this node until time.
         //    Ignore peer too
-        std::vector<unsigned char> vchData;
+        std::vector<uint8_t> vchData;
         vRecv >> vchData;
-        
+
         if (vchData.size() < 8)
         {
             printf("smsgIgnore, not enough data %" PRIszu".\n", vchData.size());
             pfrom->Misbehaving(1);
             return false;
         };
-        
+
         int64_t time;
         memcpy(&time, &vchData[0], 8);
-        
+
         pfrom->smsgData.ignoreUntil = time;
-        
+
         if (fDebugSmsg)
             printf("Peer %u is ignoring this node until %" PRI64d", ignore peer too.\n", pfrom->smsgData.nPeerId, time);
     } else
     {
         // Unknown message
     };
-    
+
     }; //  LOCK(cs_smsg);
-    
+
     return true;
 };
 
@@ -1793,12 +1791,11 @@ bool SecureMsgSendData(CNode* pto, bool fSendTrickle)
         Called from ProcessMessage
         Runs in ThreadMessageHandler2
     */
-    
+
     //printf("SecureMsgSendData() %s.\n", pto->addrName.c_str());
-    
-    
+
     int64_t now = GetTime();
-    
+
     if (pto->smsgData.lastSeen == 0)
     {
         // -- first contact
@@ -1816,76 +1813,75 @@ bool SecureMsgSendData(CNode* pto, bool fSendTrickle)
     {
         return true;
     };
-    
-    // -- When nWakeCounter == 0, resend bucket inventory.  
+
+    // -- When nWakeCounter == 0, resend bucket inventory.
     if (pto->smsgData.nWakeCounter < 1)
     {
         pto->smsgData.lastMatched = 0;
         pto->smsgData.nWakeCounter = 10 + GetRandInt(300);  // set to a random time between [10, 300] * SMSG_SEND_DELAY seconds
-        
+
         if (fDebugSmsg)
             printf("SecureMsgSendData(): nWakeCounter expired, sending bucket inventory to %s.\n"
             "Now %" PRI64d" next wake counter %u\n", pto->addrName.c_str(), now, pto->smsgData.nWakeCounter);
     };
     pto->smsgData.nWakeCounter--;
-    
+
     {
         LOCK(cs_smsg);
         std::map<int64_t, SecMsgBucket>::iterator it;
-        
+
         uint32_t nBuckets = smsgBuckets.size();
         if (nBuckets > 0) // no need to send keep alive pkts, coin messages already do that
         {
-            std::vector<unsigned char> vchData;
+            std::vector<uint8_t> vchData;
             // should reserve?
             vchData.reserve(4 + nBuckets*16); // timestamp + size + hash
-            
+
             uint32_t nBucketsShown = 0;
             vchData.resize(4);
-            
-            unsigned char* p = &vchData[4];
+
+            uint8_t* p = &vchData[4];
             for (it = smsgBuckets.begin(); it != smsgBuckets.end(); ++it)
             {
                 SecMsgBucket &bkt = it->second;
-                
+
                 uint32_t nMessages = bkt.setTokens.size();
-                
+
                 if (bkt.timeChanged < pto->smsgData.lastMatched     // peer has this bucket
                     || nMessages < 1)                               // this bucket is empty
-                    continue; 
-                
-                
+                    continue;
+
+
                 uint32_t hash = bkt.hash;
-                
-                try {
-                    vchData.resize(vchData.size() + 16);
-                } catch (std::exception& e) {
+
+                try { vchData.resize(vchData.size() + 16); } catch (std::exception& e)
+		{
                     printf("vchData.resize %" PRIszu" threw: %s.\n", vchData.size() + 16, e.what());
                     continue;
                 };
                 memcpy(p, &it->first, 8);
                 memcpy(p+8, &nMessages, 4);
                 memcpy(p+12, &hash, 4);
-                
+
                 p += 16;
                 nBucketsShown++;
                 //if (fDebug)
                 //    printf("Sending bucket %" PRI64d", size %d \n", it->first, it->second.size());
             };
-            
+
             if (vchData.size() > 4)
             {
                 memcpy(&vchData[0], &nBucketsShown, 4);
                 if (fDebugSmsg)
                     printf("Sending %d bucket headers.\n", nBucketsShown);
-                
+
                 pto->PushMessage("smsgInv", vchData);
             };
         };
     }
-    
+
     pto->smsgData.lastSeen = GetTime();
-    
+
     return true;
 };
 
@@ -1893,16 +1889,16 @@ bool SecureMsgSendData(CNode* pto, bool fSendTrickle)
 static int SecureMsgInsertAddress(CKeyID& hashKey, CPubKey& pubKey, SecMsgDB& addrpkdb)
 {
     /* insert key hash and public key to addressdb
-        
+
         should have LOCK(cs_smsg) where db is opened
-        
+
         returns
             0 success
             1 error
             4 address is already in db
     */
-    
-    
+
+
     if (addrpkdb.ExistsPK(hashKey))
     {
         //printf("DB already contains public key for address.\n");
@@ -1917,13 +1913,13 @@ static int SecureMsgInsertAddress(CKeyID& hashKey, CPubKey& pubKey, SecMsgDB& ad
         };
         return 4;
     };
-    
+
     if (!addrpkdb.WritePK(hashKey, pubKey))
     {
         printf("Write pair failed.\n");
         return 1;
     };
-    
+
     return 0;
 };
 
@@ -1933,25 +1929,26 @@ int SecureMsgInsertAddress(CKeyID& hashKey, CPubKey& pubKey)
     {
         LOCK(cs_smsgDB);
         SecMsgDB addrpkdb;
-        
+
         if (!addrpkdb.Open("cr+"))
             return 1;
-        
+
         rv = SecureMsgInsertAddress(hashKey, pubKey, addrpkdb);
     }
     return rv;
 };
 
+
 static bool ScanBlock(CBlock& block, CTxDB& txdb, SecMsgDB& addrpkdb,
     uint32_t& nTransactions, uint32_t& nElements, uint32_t& nPubkeys, uint32_t& nDuplicates)
 {
     AssertLockHeld(cs_smsgDB);
-    
+
     valtype vch;
     opcodetype opcode;
-    
+
     // -- only scan inputs of standard txns and coinstakes
-    
+
     BOOST_FOREACH(CTransaction& tx, block.vtx)
     {
         // - harvest public keys from coinstake txns
@@ -1963,18 +1960,18 @@ static bool ScanBlock(CBlock& block, CTxDB& txdb, SecMsgDB& addrpkdb,
             {
                 if (!txout.scriptPubKey.GetOp(pc, opcode, vch))
                     break;
-                
+
                 if (vch.size() == 33) // pubkey
                 {
                     CPubKey pubKey(vch);
-                    
+
                     if (!pubKey.IsValid()
                         || !pubKey.IsCompressed())
                     {
                         printf("Public key is invalid %s.\n", HexStr(pubKey).c_str());
                         continue;
                     };
-                    
+
                     CKeyID addrKey = pubKey.GetID();
                     switch (SecureMsgInsertAddress(addrKey, pubKey, addrpkdb))
                     {
@@ -2016,7 +2013,7 @@ static bool ScanBlock(CBlock& block, CTxDB& txdb, SecMsgDB& addrpkdb,
                             printf("Public key is invalid %s.\n", HexStr(pubKey).c_str());
                             continue;
                         };
-                        
+
                         CKeyID addrKey = pubKey.GetID();
                         switch (SecureMsgInsertAddress(addrKey, pubKey, addrpkdb))
                         {
@@ -2041,39 +2038,40 @@ static bool ScanBlock(CBlock& block, CTxDB& txdb, SecMsgDB& addrpkdb,
     return true;
 };
 
+
 bool SecureMsgScanBlock(CBlock& block)
 {
     /*
     scan block for public key addresses
     called from ProcessMessage() in main where strCommand == "block"
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgScanBlock().\n");
-    
+
     uint32_t nTransactions  = 0;
     uint32_t nElements      = 0;
     uint32_t nPubkeys       = 0;
     uint32_t nDuplicates    = 0;
-    
+
     {
         LOCK(cs_smsgDB);
         CTxDB txdb("r");
-        
+
         SecMsgDB addrpkdb;
         if (!addrpkdb.Open("cw")
             || !addrpkdb.TxnBegin())
             return false;
-        
+
         ScanBlock(block, txdb, addrpkdb,
             nTransactions, nElements, nPubkeys, nDuplicates);
-        
+
         addrpkdb.TxnCommit();
     }
-    
+
     if (fDebugSmsg)
         printf("Found %u transactions, %u inputs, %u new public keys, %u duplicates.\n", nTransactions, nElements, nPubkeys, nDuplicates);
-    
+
     return true;
 };
 
@@ -2081,49 +2079,49 @@ bool ScanChainForPublicKeys(CBlockIndex* pindexStart)
 {
     printf("Scanning block chain for public keys.\n");
     int64_t nStart = GetTimeMillis();
-    
+
     if (fDebugSmsg)
         printf("From height %u.\n", pindexStart->nHeight);
-    
+
     // -- public keys are in txin.scriptSig
     //    matching addresses are in scriptPubKey of txin's referenced output
-    
+
     uint32_t nBlocks        = 0;
     uint32_t nTransactions  = 0;
     uint32_t nInputs        = 0;
     uint32_t nPubkeys       = 0;
     uint32_t nDuplicates    = 0;
-    
+
     {
         LOCK(cs_smsgDB);
-    
+
         CTxDB txdb("r");
-        
+
         SecMsgDB addrpkdb;
         if (!addrpkdb.Open("cw")
             || !addrpkdb.TxnBegin())
             return false;
-        
+
         CBlockIndex* pindex = pindexStart;
         while (pindex)
         {
             nBlocks++;
             CBlock block;
             block.ReadFromDisk(pindex, true);
-            
+
             ScanBlock(block, txdb, addrpkdb,
                 nTransactions, nInputs, nPubkeys, nDuplicates);
-            
+
             pindex = pindex->pnext;
         };
-        
+
         addrpkdb.TxnCommit();
     };
-    
+
     printf("Scanned %u blocks, %u transactions, %u inputs\n", nBlocks, nTransactions, nInputs);
     printf("Found %u public keys, %u duplicates.\n", nPubkeys, nDuplicates);
     printf("Took %" PRI64d" ms\n", GetTimeMillis() - nStart);
-    
+
     return true;
 };
 
@@ -2138,9 +2136,9 @@ bool SecureMsgScanBlockChain()
             printf("Error: pindexGenesisBlock not set.\n");
             return false;
         };
-        
-        
-        try { // -- in try to catch errors opening db, 
+
+
+        try { // -- in try to catch errors opening db,
             if (!ScanChainForPublicKeys(pindexScan))
                 return false;
         } catch (std::exception& e)
@@ -2153,7 +2151,7 @@ bool SecureMsgScanBlockChain()
         printf("ScanChainForPublicKeys() Could not lock main.\n");
         return false;
     };
-    
+
     return true;
 };
 
@@ -2161,58 +2159,58 @@ bool SecureMsgScanBuckets()
 {
     if (fDebugSmsg)
         printf("SecureMsgScanBuckets()\n");
-    
+
     if (!fSecMsgEnabled
         || pwalletMain->IsLocked())
         return false;
-    
+
     int64_t  mStart         = GetTimeMillis();
     int64_t  now            = GetTime();
     uint32_t nFiles         = 0;
     uint32_t nMessages      = 0;
     uint32_t nFoundMessages = 0;
-    
+
     fs::path pathSmsgDir = GetDataDir() / "smsgStore";
     fs::directory_iterator itend;
-    
+
     if (!fs::exists(pathSmsgDir)
         || !fs::is_directory(pathSmsgDir))
     {
         printf("Message store directory does not exist.\n");
         return 0; // not an error
     };
-    
+
     SecureMessage smsg;
-    std::vector<unsigned char> vchData;
-    
+    std::vector<uint8_t> vchData;
+
     for (fs::directory_iterator itd(pathSmsgDir) ; itd != itend ; ++itd)
     {
         if (!fs::is_regular_file(itd->status()))
             continue;
-        
+
         std::string fileType = (*itd).path().extension().string();
-        
+
         if (fileType.compare(".dat") != 0)
             continue;
-            
+
         std::string fileName = (*itd).path().filename().string();
-        
-        
+
+
         if (fDebugSmsg)
             printf("Processing file: %s.\n", fileName.c_str());
-        
+
         nFiles++;
-        
+
         // TODO files must be split if > 2GB
         // time_noFile.dat
         size_t sep = fileName.find_first_of("_");
         if (sep == std::string::npos)
             continue;
-        
+
         std::string stime = fileName.substr(0, sep);
-        
+
         int64_t fileTime = boost::lexical_cast<int64_t>(stime);
-        
+
         if (fileTime < now - SMSG_RETENTION)
         {
             printf("Dropping file %s, expired.\n", fileName.c_str());
@@ -2224,14 +2222,14 @@ bool SecureMsgScanBuckets()
             };
             continue;
         };
-        
+
         if (boost::algorithm::ends_with(fileName, "_wl.dat"))
         {
             if (fDebugSmsg)
                 printf("Skipping wallet locked file: %s.\n", fileName.c_str());
             continue;
         };
-        
+
         {
             LOCK(cs_smsg);
             FILE *fp;
@@ -2241,11 +2239,11 @@ bool SecureMsgScanBuckets()
                 printf("Error opening file: %s\n", strerror(errno));
                 continue;
             };
-            
+
             for (;;)
             {
                 errno = 0;
-                if (fread(&smsg.hash[0], sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
+                if (fread(&smsg.hash[0], sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
                 {
                     if (errno != 0)
                     {
@@ -2256,25 +2254,23 @@ bool SecureMsgScanBuckets()
                     };
                     break;
                 };
-                
-                try {
-                    vchData.resize(smsg.nPayload);
-                } catch (std::exception& e)
+
+                try { vchData.resize(smsg.nPayload); } catch (std::exception& e)
                 {
                     printf("SecureMsgWalletUnlocked(): Could not resize vchData, %u, %s\n", smsg.nPayload, e.what());
                     fclose(fp);
                     return 1;
                 };
-                
-                if (fread(&vchData[0], sizeof(unsigned char), smsg.nPayload, fp) != smsg.nPayload)
+
+                if (fread(&vchData[0], sizeof(uint8_t), smsg.nPayload, fp) != smsg.nPayload)
                 {
                     printf("fread data failed: %s\n", strerror(errno));
                     break;
                 };
-                
-                // -- don't report to gui, 
+
+                // -- don't report to gui,
                 int rv = SecureMsgScanMessage(&smsg.hash[0], &vchData[0], smsg.nPayload, false);
-                
+
                 if (rv == 0)
                 {
                     nFoundMessages++;
@@ -2283,12 +2279,12 @@ bool SecureMsgScanBuckets()
                 {
                     // SecureMsgScanMessage failed
                 };
-                
+
                 nMessages ++;
             };
-            
+
             fclose(fp);
-            
+
             // -- remove wl file when scanned
             try {
                 fs::remove((*itd).path());
@@ -2299,10 +2295,10 @@ bool SecureMsgScanBuckets()
             };
         };
     };
-    
+
     printf("Processed %u files, scanned %u messages, received %u messages.\n", nFiles, nMessages, nFoundMessages);
     printf("Took %" PRI64d" ms\n", GetTimeMillis() - mStart);
-    
+
     return true;
 }
 
@@ -2310,63 +2306,62 @@ bool SecureMsgScanBuckets()
 int SecureMsgWalletUnlocked()
 {
     /*
-    When the wallet is unlocked scan messages received while wallet was locked.
+    When the wallet is unlocked, scan messages received while wallet was locked.
     */
     if (!fSecMsgEnabled)
         return 0;
-    
-    
+
     printf("SecureMsgWalletUnlocked()\n");
-    
+
     if (pwalletMain->IsLocked())
     {
         printf("Error: Wallet is locked.\n");
         return 1;
     };
-    
+
     int64_t  now            = GetTime();
     uint32_t nFiles         = 0;
     uint32_t nMessages      = 0;
     uint32_t nFoundMessages = 0;
-    
+
     fs::path pathSmsgDir = GetDataDir() / "smsgStore";
     fs::directory_iterator itend;
-    
+
     if (!fs::exists(pathSmsgDir)
         || !fs::is_directory(pathSmsgDir))
     {
         printf("Message store directory does not exist.\n");
         return 0; // not an error
     };
-    
+
     SecureMessage smsg;
-    std::vector<unsigned char> vchData;
-    
+    std::vector<uint8_t> vchData;
+
     for (fs::directory_iterator itd(pathSmsgDir) ; itd != itend ; ++itd)
     {
         if (!fs::is_regular_file(itd->status()))
             continue;
-        
+
         std::string fileName = (*itd).path().filename().string();
-        
+
         if (!boost::algorithm::ends_with(fileName, "_wl.dat"))
             continue;
-        
+
         if (fDebugSmsg)
             printf("Processing file: %s.\n", fileName.c_str());
-        
+
         nFiles++;
-        
+
         // TODO files must be split if > 2GB
         // time_noFile_wl.dat
         size_t sep = fileName.find_first_of("_");
         if (sep == std::string::npos)
             continue;
-        
+
         std::string stime = fileName.substr(0, sep);
-        
+
         int64_t fileTime = boost::lexical_cast<int64_t>(stime);
-        
+
         if (fileTime < now - SMSG_RETENTION)
         {
             printf("Dropping wallet locked file %s, expired.\n", fileName.c_str());
@@ -2379,7 +2374,7 @@ int SecureMsgWalletUnlocked()
             };
             continue;
         };
-        
+
         {
             LOCK(cs_smsg);
             FILE *fp;
@@ -2389,11 +2384,11 @@ int SecureMsgWalletUnlocked()
                 printf("Error opening file: %s\n", strerror(errno));
                 continue;
             };
-            
+
             for (;;)
             {
                 errno = 0;
-                if (fread(&smsg.hash[0], sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
+                if (fread(&smsg.hash[0], sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
                 {
                     if (errno != 0)
                     {
@@ -2404,25 +2399,23 @@ int SecureMsgWalletUnlocked()
                     };
                     break;
                 };
-                
-                try {
-                    vchData.resize(smsg.nPayload);
-                } catch (std::exception& e)
+
+                try { vchData.resize(smsg.nPayload); } catch (std::exception& e)
                 {
                     printf("SecureMsgWalletUnlocked(): Could not resize vchData, %u, %s\n", smsg.nPayload, e.what());
                     fclose(fp);
                     return 1;
                 };
-                
-                if (fread(&vchData[0], sizeof(unsigned char), smsg.nPayload, fp) != smsg.nPayload)
+
+                if (fread(&vchData[0], sizeof(uint8_t), smsg.nPayload, fp) != smsg.nPayload)
                 {
                     printf("fread data failed: %s\n", strerror(errno));
                     break;
                 };
-                
-                // -- don't report to gui, 
+
+                // -- don't report to gui,
                 int rv = SecureMsgScanMessage(&smsg.hash[0], &vchData[0], smsg.nPayload, false);
-                
+
                 if (rv == 0)
                 {
                     nFoundMessages++;
@@ -2431,12 +2424,12 @@ int SecureMsgWalletUnlocked()
                 {
                     // SecureMsgScanMessage failed
                 };
-                
+
                 nMessages ++;
             };
-            
+
             fclose(fp);
-            
+
             // -- remove wl file when scanned
             try {
                 fs::remove((*itd).path());
@@ -2447,12 +2440,11 @@ int SecureMsgWalletUnlocked()
             };
         };
     };
-    
+
     printf("Processed %u files, scanned %u messages, received %u messages.\n", nFiles, nMessages, nFoundMessages);
     
     // -- notify gui
     NotifySecMsgWalletUnlocked();
-    
     return 0;
 };
 
@@ -2460,14 +2452,14 @@ int SecureMsgWalletKeyChanged(std::string sAddress, std::string sLabel, ChangeTy
 {
     if (!fSecMsgEnabled)
         return 0;
-    
+
     printf("SecureMsgWalletKeyChanged()\n");
-    
+
     // TODO: default recv and recvAnon
-    
+
     {
         LOCK(cs_smsg);
-        
+
         switch(mode)
         {
             case CT_NEW:
@@ -2485,56 +2477,56 @@ int SecureMsgWalletKeyChanged(std::string sAddress, std::string sLabel, ChangeTy
             default:
                 break;
         }
-        
+
     }; // LOCK(cs_smsg);
-    
-    
+
+
     return 0;
 };
 
-int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, bool reportToGui)
+int SecureMsgScanMessage(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, bool reportToGui)
 {
-    /* 
+    /*
     Check if message belongs to this node.
     If so add to inbox db.
-    
+
     if !reportToGui don't fire NotifySecMsgInboxChanged
      - loads messages received when wallet locked in bulk.
-    
+
     returns
         0 success,
         1 error
         2 no match
         3 wallet is locked - message stored for scanning later.
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgScanMessage()\n");
-    
+
     if (pwalletMain->IsLocked())
     {
         if (fDebugSmsg)
             printf("ScanMessage: Wallet is locked, storing message to scan later.\n");
-        
+
         int rv;
         if ((rv = SecureMsgStoreUnscanned(pHeader, pPayload, nPayload)) != 0)
             return 1;
-        
+
         return 3;
     };
-    
+
     std::string addressTo;
     MessageData msg; // placeholder
     bool fOwnMessage = false;
-    
+
     for (std::vector<SecMsgAddress>::iterator it = smsgAddresses.begin(); it != smsgAddresses.end(); ++it)
     {
         if (!it->fReceiveEnabled)
             continue;
-        
+
         CBitcoinAddress coinAddress(it->sAddress);
         addressTo = coinAddress.ToString();
-        
+
         if (!it->fReceiveAnon)
         {
             // -- have to do full decrypt to see address from
@@ -2542,40 +2534,40 @@ int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32
             {
                 if (fDebugSmsg)
                     printf("Decrypted message with %s.\n", addressTo.c_str());
-                
+
                 if (msg.sFromAddress.compare("anon") != 0)
                     fOwnMessage = true;
                 break;
             };
         } else
         {
-            
+
             if (SecureMsgDecrypt(true, addressTo, pHeader, pPayload, nPayload, msg) == 0)
             {
                 if (fDebugSmsg)
                     printf("Decrypted message with %s.\n", addressTo.c_str());
-                
+
                 fOwnMessage = true;
                 break;
             };
         }
     };
-    
+
     if (fOwnMessage)
     {
         // -- save to inbox
         SecureMessage* psmsg = (SecureMessage*) pHeader;
         std::string sPrefix("im");
-        unsigned char chKey[18];
+        uint8_t chKey[18];
         memcpy(&chKey[0],  sPrefix.data(),    2);
         memcpy(&chKey[2],  &psmsg->timestamp, 8);
         memcpy(&chKey[10], pPayload,          8);
-        
+
         SecMsgStored smsgInbox;
         smsgInbox.timeReceived  = GetTime();
         smsgInbox.status        = (SMSG_MASK_UNREAD) & 0xFF;
         smsgInbox.sAddrTo       = addressTo;
-        
+
         // -- data may not be contiguous
         try {
             smsgInbox.vchMessage.resize(SMSG_HDR_LEN + nPayload);
@@ -2585,11 +2577,11 @@ int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32
         };
         memcpy(&smsgInbox.vchMessage[0], pHeader, SMSG_HDR_LEN);
         memcpy(&smsgInbox.vchMessage[SMSG_HDR_LEN], pPayload, nPayload);
-        
+
         {
             LOCK(cs_smsgDB);
             SecMsgDB dbInbox;
-            
+
             if (dbInbox.Open("cw"))
             {
                 if (dbInbox.ExistsSmesg(chKey))
@@ -2599,7 +2591,7 @@ int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32
                 } else
                 {
                     dbInbox.WriteSmesg(chKey, smsgInbox);
-                    
+
                     if (reportToGui)
                         NotifySecMsgInboxChanged(smsgInbox);
                     printf("SecureMsg saved to inbox, received with %s.\n", addressTo.c_str());
@@ -2607,7 +2599,7 @@ int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32
             };
         }
     };
-    
+
     return 0;
 };
 
@@ -2615,13 +2607,13 @@ int SecureMsgGetLocalKey(CKeyID& ckid, CPubKey& cpkOut)
 {
     if (fDebugSmsg)
         printf("SecureMsgGetLocalKey()\n");
-    
+
     CKey key;
     if (!pwalletMain->GetKey(ckid, key))
         return 4;
-    
+
     key.SetCompressedPubKey(); // make sure key is compressed
-    
+
     cpkOut = key.GetPubKey();
     if (!cpkOut.IsValid()
         || !cpkOut.IsCompressed())
@@ -2629,7 +2621,7 @@ int SecureMsgGetLocalKey(CKeyID& ckid, CPubKey& cpkOut)
         printf("Public key is invalid %s.\n", ValueString(cpkOut.Raw()).c_str());
         return 1;
     };
-    
+
     return 0;
 };
 
@@ -2642,22 +2634,22 @@ int SecureMsgGetLocalPublicKey(std::string& strAddress, std::string& strPublicKe
         3 address does not refer to a key
         4 address not in wallet
     */
-    
+
     CBitcoinAddress address;
     if (!address.SetString(strAddress))
         return 2; // Invalid coin address
-    
+
     CKeyID keyID;
     if (!address.GetKeyID(keyID))
         return 3;
-    
+
     int rv;
     CPubKey pubKey;
     if ((rv = SecureMsgGetLocalKey(keyID, pubKey)) != 0)
         return rv;
-    
+
     strPublicKey = EncodeBase58(pubKey.Raw());
-    
+
     return 0;
 };
 
@@ -2670,21 +2662,21 @@ int SecureMsgGetStoredKey(CKeyID& ckid, CPubKey& cpkOut)
     */
     if (fDebugSmsg)
         printf("SecureMsgGetStoredKey().\n");
-    
+
     {
         LOCK(cs_smsgDB);
         SecMsgDB addrpkdb;
-        
+
         if (!addrpkdb.Open("r"))
             return 1;
-        
+
         if (!addrpkdb.ReadPK(ckid, cpkOut))
         {
             //printf("addrpkdb.Read failed: %s.\n", coinAddress.ToString().c_str());
             return 2;
         };
     }
-    
+
     return 0;
 };
 
@@ -2693,7 +2685,7 @@ int SecureMsgAddAddress(std::string& address, std::string& publicKey)
     /*
         Add address and matching public key to the database
         address and publicKey are in base58
-        
+
         returns
             0 success
             1 error
@@ -2702,27 +2694,27 @@ int SecureMsgAddAddress(std::string& address, std::string& publicKey)
             4 address is already in db
             5 address is invalid
     */
-    
+
     CBitcoinAddress coinAddress(address);
-    
+
     if (!coinAddress.IsValid())
     {
         printf("Address is not valid: %s.\n", address.c_str());
         return 5;
     };
-    
+
     CKeyID hashKey;
-    
+
     if (!coinAddress.GetKeyID(hashKey))
     {
         printf("coinAddress.GetKeyID failed: %s.\n", coinAddress.ToString().c_str());
         return 5;
     };
-    
-    std::vector<unsigned char> vchTest;
+
+    std::vector<uint8_t> vchTest;
     DecodeBase58(publicKey, vchTest);
     CPubKey pubKey(vchTest);
-    
+
     // -- check that public key matches address hash
     CKey keyT;
     if (!keyT.SetPubKey(pubKey))
@@ -2730,39 +2722,39 @@ int SecureMsgAddAddress(std::string& address, std::string& publicKey)
         printf("SetPubKey failed.\n");
         return 2;
     };
-    
+
     keyT.SetCompressedPubKey();
     CPubKey pubKeyT = keyT.GetPubKey();
-    
+
     CBitcoinAddress addressT(address);
-    
+
     if (addressT.ToString().compare(address) != 0)
     {
         printf("Public key does not hash to address, addressT %s.\n", addressT.ToString().c_str());
         return 3;
     };
-    
+
     return SecureMsgInsertAddress(hashKey, pubKey);
 };
 
-int SecureMsgRetrieve(SecMsgToken &token, std::vector<unsigned char>& vchData)
+int SecureMsgRetrieve(SecMsgToken &token, std::vector<uint8_t>& vchData)
 {
     if (fDebugSmsg)
         printf("SecureMsgRetrieve() %" PRI64d".\n", token.timestamp);
     
     // -- has cs_smsg lock from SecureMsgReceiveData
-    
+
     fs::path pathSmsgDir = GetDataDir() / "smsgStore";
-    
+
     //printf("token.offset %" PRI64d".\n", token.offset); // DEBUG
     int64_t bucket = token.timestamp - (token.timestamp % SMSG_BUCKET_LEN);
     std::string fileName = boost::lexical_cast<std::string>(bucket) + "_01.dat";
     fs::path fullpath = pathSmsgDir / fileName;
-    
+
     //printf("bucket %" PRI64d".\n", bucket);
     //printf("bucket lld %lld.\n", bucket);
     //printf("fileName %s.\n", fileName.c_str());
-    
+
     FILE *fp;
     errno = 0;
     if (!(fp = fopen(fullpath.string().c_str(), "rb")))
@@ -2770,7 +2762,7 @@ int SecureMsgRetrieve(SecMsgToken &token, std::vector<unsigned char>& vchData)
         printf("Error opening file: %s\nPath %s\n", strerror(errno), fullpath.string().c_str());
         return 1;
     };
-    
+
     errno = 0;
     if (fseek(fp, token.offset, SEEK_SET) != 0)
     {
@@ -2778,56 +2770,56 @@ int SecureMsgRetrieve(SecMsgToken &token, std::vector<unsigned char>& vchData)
         fclose(fp);
         return 1;
     };
-    
+
     SecureMessage smsg;
     errno = 0;
-    if (fread(&smsg.hash[0], sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
+    if (fread(&smsg.hash[0], sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN)
     {
         printf("fread header failed: %s\n", strerror(errno));
         fclose(fp);
         return 1;
     };
-    
+
     try {
         vchData.resize(SMSG_HDR_LEN + smsg.nPayload);
     } catch (std::exception& e) {
         printf("SecureMsgRetrieve(): Could not resize vchData, %u, %s\n", SMSG_HDR_LEN + smsg.nPayload, e.what());
         return 1;
     };
-    
+
     memcpy(&vchData[0], &smsg.hash[0], SMSG_HDR_LEN);
     errno = 0;
-    if (fread(&vchData[SMSG_HDR_LEN], sizeof(unsigned char), smsg.nPayload, fp) != smsg.nPayload)
+    if (fread(&vchData[SMSG_HDR_LEN], sizeof(uint8_t), smsg.nPayload, fp) != smsg.nPayload)
     {
         printf("fread data failed: %s. Wanted %u bytes.\n", strerror(errno), smsg.nPayload);
         fclose(fp);
         return 1;
     };
-    
-    
+
+
     fclose(fp);
-    
+
     return 0;
 };
 
-int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
+int SecureMsgReceive(CNode* pfrom, std::vector<uint8_t>& vchData)
 {
     if (fDebugSmsg)
         printf("SecureMsgReceive().\n");
-    
+
     if (vchData.size() < 12) // nBunch4 + timestamp8
     {
         printf("Error: not enough data.\n");
         return 1;
     };
-    
+
     uint32_t nBunch;
     int64_t bktTime;
-    
+
     memcpy(&nBunch, &vchData[0], 4);
     memcpy(&bktTime, &vchData[4], 8);
-    
-    
+
+
     // -- check bktTime ()
     //    bucket may not exist yet - will be created when messages are added
     int64_t now = GetTime();
@@ -2845,9 +2837,9 @@ int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
         // misbehave?
         return 1;
     };
-    
+
     std::map<int64_t, SecMsgBucket>::iterator itb;
-    
+
     if (nBunch == 0 || nBunch > 500)
     {
         printf("Error: Invalid no. messages received in bunch %u, for bucket %" PRI64d".\n", nBunch, bktTime);
@@ -2859,9 +2851,9 @@ int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
             itb->second.nLockCount = 0;
         return 1;
     };
-    
+
     uint32_t n = 12;
-    
+
     for (uint32_t i = 0; i < nBunch; ++i)
     {
         if (vchData.size() - n < SMSG_HDR_LEN)
@@ -2869,9 +2861,9 @@ int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
             printf("Error: not enough data sent, n = %u.\n", n);
             break;
         };
-        
+
         SecureMessage* psmsg = (SecureMessage*) &vchData[n];
-        
+
         int rv;
         if ((rv = SecureMsgValidate(&vchData[n], &vchData[n + SMSG_HDR_LEN], psmsg->nPayload)) != 0)
         {
@@ -2885,22 +2877,22 @@ int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
             };
             continue;
         };
-        
+
         // -- store message, but don't hash bucket
         if (SecureMsgStore(&vchData[n], &vchData[n + SMSG_HDR_LEN], psmsg->nPayload, false) != 0)
         {
             // message dropped
             break; // continue?
         };
-        
+
         if (SecureMsgScanMessage(&vchData[n], &vchData[n + SMSG_HDR_LEN], psmsg->nPayload, true) != 0)
         {
             // message recipient is not this node (or failed)
         };
-        
+
         n += SMSG_HDR_LEN + psmsg->nPayload;
     };
-    
+
     // -- if messages have been added, bucket must exist now
     itb = smsgBuckets.find(bktTime);
     if (itb == smsgBuckets.end())
@@ -2909,32 +2901,32 @@ int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData)
             printf("Don't have bucket %" PRI64d".\n", bktTime);
         return 1;
     };
-    
+
     itb->second.nLockCount  = 0; // this node has received data from peer, release lock
     itb->second.nLockPeerId = 0;
     itb->second.hashBucket();
-    
+
     return 0;
 };
 
-int SecureMsgStoreUnscanned(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload)
+int SecureMsgStoreUnscanned(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload)
 {
     /*
     When the wallet is locked a copy of each received message is stored to be scanned later if wallet is unlocked
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgStoreUnscanned()\n");
-    
+
     if (!pHeader
         || !pPayload)
     {
         printf("Error: null pointer to header or payload.\n");
         return 1;
     };
-    
+
     SecureMessage* psmsg = (SecureMessage*) pHeader;
-    
+
     fs::path pathSmsgDir;
     try {
         pathSmsgDir = GetDataDir() / "smsgStore";
@@ -2944,7 +2936,7 @@ int SecureMsgStoreUnscanned(unsigned char *pHeader, unsigned char *pPayload, uin
         printf("Error: Failed to create directory %s - %s\n", pathSmsgDir.string().c_str(), ex.what());
         return 1;
     };
-    
+
     int64_t now = GetTime();
     if (psmsg->timestamp > now + SMSG_TIME_LEEWAY)
     {
@@ -2956,12 +2948,12 @@ int SecureMsgStoreUnscanned(unsigned char *pHeader, unsigned char *pPayload, uin
         printf("Message < SMSG_RETENTION.\n");
         return 1;
     };
-    
+
     int64_t bucket = psmsg->timestamp - (psmsg->timestamp % SMSG_BUCKET_LEN);
 
     std::string fileName = boost::lexical_cast<std::string>(bucket) + "_01_wl.dat";
     fs::path fullpath = pathSmsgDir / fileName;
-    
+
     FILE *fp;
     errno = 0;
     if (!(fp = fopen(fullpath.string().c_str(), "ab")))
@@ -2969,36 +2961,36 @@ int SecureMsgStoreUnscanned(unsigned char *pHeader, unsigned char *pPayload, uin
         printf("Error opening file: %s\n", strerror(errno));
         return 1;
     };
-    
-    if (fwrite(pHeader, sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN
-        || fwrite(pPayload, sizeof(unsigned char), nPayload, fp) != nPayload)
+
+    if (fwrite(pHeader, sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN
+        || fwrite(pPayload, sizeof(uint8_t), nPayload, fp) != nPayload)
     {
         printf("fwrite failed: %s\n", strerror(errno));
         fclose(fp);
         return 1;
     };
-    
+
     fclose(fp);
-    
+
     return 0;
 };
 
 
-int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, bool fUpdateBucket)
+int SecureMsgStore(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, bool fUpdateBucket)
 {
     if (fDebugSmsg)
         printf("SecureMsgStore()\n");
-    
+
     if (!pHeader
         || !pPayload)
     {
         printf("Error: null pointer to header or payload.\n");
         return 1;
     };
-    
+
     SecureMessage* psmsg = (SecureMessage*) pHeader;
-    
-    
+
+
     long int ofs;
     fs::path pathSmsgDir;
     try {
@@ -3009,7 +3001,7 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
         printf("Error: Failed to create directory %s - %s\n", pathSmsgDir.string().c_str(), ex.what());
         return 1;
     };
-    
+
     int64_t now = GetTime();
     if (psmsg->timestamp > now + SMSG_TIME_LEEWAY)
     {
@@ -3021,15 +3013,15 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
         printf("Message < SMSG_RETENTION.\n");
         return 1;
     };
-    
+
     int64_t bucket = psmsg->timestamp - (psmsg->timestamp % SMSG_BUCKET_LEN);
-    
+
     {
         // -- must lock cs_smsg before calling
         //LOCK(cs_smsg);
-        
+
         SecMsgToken token(psmsg->timestamp, pPayload, nPayload, 0);
-        
+
         std::set<SecMsgToken>& tokenSet = smsgBuckets[bucket].setTokens;
         std::set<SecMsgToken>::iterator it;
         it = tokenSet.find(token);
@@ -3040,9 +3032,9 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
             {
                 printf("nPayload: %u\n", nPayload);
                 printf("bucket: %" PRI64d"\n", bucket);
-                
+
                 printf("message ts: %" PRI64d, token.timestamp);
-                std::vector<unsigned char> vchShow;
+                std::vector<uint8_t> vchShow;
                 vchShow.resize(8);
                 memcpy(&vchShow[0], token.sample, 8);
                 printf(" sample %s\n", ValueString(vchShow).c_str());
@@ -3059,10 +3051,10 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
             };
             return 1;
         };
-        
+
         std::string fileName = boost::lexical_cast<std::string>(bucket) + "_01.dat";
         fs::path fullpath = pathSmsgDir / fileName;
-        
+
         FILE *fp;
         errno = 0;
         if (!(fp = fopen(fullpath.string().c_str(), "ab")))
@@ -3070,7 +3062,7 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
             printf("Error opening file: %s\n", strerror(errno));
             return 1;
         };
-        
+
         // -- on windows ftell will always return 0 after fopen(ab), call fseek to set.
         errno = 0;
         if (fseek(fp, 0, SEEK_END) != 0)
@@ -3078,29 +3070,29 @@ int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPa
             printf("Error fseek failed: %s\n", strerror(errno));
             return 1;
         };
-        
-        
+
+
         ofs = ftell(fp);
-        
-        if (fwrite(pHeader, sizeof(unsigned char), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN
-            || fwrite(pPayload, sizeof(unsigned char), nPayload, fp) != nPayload)
+
+        if (fwrite(pHeader, sizeof(uint8_t), SMSG_HDR_LEN, fp) != (size_t)SMSG_HDR_LEN
+            || fwrite(pPayload, sizeof(uint8_t), nPayload, fp) != nPayload)
         {
             printf("fwrite failed: %s\n", strerror(errno));
             fclose(fp);
             return 1;
         };
-        
+
         fclose(fp);
-        
+
         token.offset = ofs;
-        
+
         //printf("token.offset: %" PRI64d"\n", token.offset); // DEBUG
         tokenSet.insert(token);
-        
+
         if (fUpdateBucket)
             smsgBuckets[bucket].hashBucket();
     };
-    
+
     //if (fDebugSmsg)
     printf("SecureMsg added to bucket %" PRI64d".\n", bucket);
     return 0;
@@ -3110,8 +3102,8 @@ int SecureMsgStore(SecureMessage& smsg, bool fUpdateBucket)
 {
     return SecureMsgStore(&smsg.hash[0], smsg.pPayload, smsg.nPayload, fUpdateBucket);
 };
-  
-int SecureMsgValidate(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload)
+
+int SecureMsgValidate(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload)
 {
     /*
     returns
@@ -3123,36 +3115,40 @@ int SecureMsgValidate(unsigned char *pHeader, unsigned char *pPayload, uint32_t
         5 payload is too large
     */
     SecureMessage* psmsg = (SecureMessage*) pHeader;
-    
+
     if (psmsg->version[0] != 1)
         return 4;
-    
+
     if (nPayload > SMSG_MAX_MSG_WORST)
         return 5;
-    
-    unsigned char civ[32];
-    unsigned char sha256Hash[32];
+
+    uint8_t civ[32];
+    uint8_t sha256Hash[32];
     int rv = 2; // invalid
-    
+
     uint32_t nonse;
     memcpy(&nonse, &psmsg->nonse[0], 4);
-    
+
     if (fDebugSmsg)
         printf("SecureMsgValidate() nonse %u.\n", nonse);
-    
+
     for (int i = 0; i < 32; i+=4)
         memcpy(civ+i, &nonse, 4);
-    
-    HMAC_CTX ctx;
-    HMAC_CTX_init(&ctx);
-    
-    unsigned int nBytes;
-    if (!HMAC_Init_ex(&ctx, &civ[0], 32, EVP_sha256(), NULL)
-        || !HMAC_Update(&ctx, (unsigned char*) pHeader+4, SMSG_HDR_LEN-4)
-        || !HMAC_Update(&ctx, (unsigned char*) pPayload, nPayload)
-        || !HMAC_Update(&ctx, pPayload, nPayload)
-        || !HMAC_Final(&ctx, sha256Hash, &nBytes)
-        || nBytes != 32)
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX *ctx = HMAC_CTX_new();
+#else
+    HMAC_CTX *ctx = new HMAC_CTX();
+    HMAC_CTX_init(ctx);
+#endif
+
+    uint32_t nBytes;
+    if (!HMAC_Init_ex(ctx, &civ[0], 32, EVP_sha256(), NULL)
+	|| !HMAC_Update(ctx, (uint8_t*) pHeader+4, SMSG_HDR_LEN-4)
+	|| !HMAC_Update(ctx, (uint8_t*) pPayload, nPayload)
+	|| !HMAC_Update(ctx, pPayload, nPayload)
+	|| !HMAC_Final(ctx, sha256Hash, &nBytes)
+	|| nBytes != 32)
     {
         if (fDebugSmsg)
             printf("HMAC error.\n");
@@ -3167,7 +3163,7 @@ int SecureMsgValidate(unsigned char *pHeader, unsigned char *pPayload, uint32_t
                 printf("Hash Valid.\n");
             rv = 0; // smsg is valid
         };
-        
+
         if (memcmp(psmsg->hash, sha256Hash, 4) != 0)
         {
              if (fDebugSmsg)
@@ -3175,12 +3171,17 @@ int SecureMsgValidate(unsigned char *pHeader, unsigned char *pPayload, uint32_t
             rv = 3; // checksum mismatch
         }
     }
-    HMAC_CTX_cleanup(&ctx);
-    
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX_free(ctx);
+#else
+    HMAC_CTX_cleanup(ctx);
+    delete ctx;
+#endif
+
     return rv;
 };
 
-int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload)
+int SecureMsgSetHash(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload)
 {
     /*  proof of work and checksum
         
@@ -3192,48 +3193,52 @@ int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t n
             2 stopped due to node shutdown
         
     */
-    
+
     SecureMessage* psmsg = (SecureMessage*) pHeader;
-    
+
     int64_t nStart = GetTimeMillis();
-    unsigned char civ[32];
-    unsigned char sha256Hash[32];
-    
-    //std::vector<unsigned char> vchHash;
+    uint8_t civ[32];
+    uint8_t sha256Hash[32];
+
+    //std::vector<uint8_t> vchHash;
     //vchHash.resize(32);
-    
+
     bool found = false;
-    HMAC_CTX ctx;
-    HMAC_CTX_init(&ctx);
-    
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX *ctx = HMAC_CTX_new();
+#else
+    HMAC_CTX *ctx = new HMAC_CTX();
+    HMAC_CTX_init(ctx);
+#endif
+
     uint32_t nonse = 0;
-    
+
     //CBigNum bnTarget(2);
     //bnTarget = bnTarget.pow(256 - 40);
-    
+
     // -- break for HMAC_CTX_cleanup
     for (;;)
     {
         if (!fSecMsgEnabled)
            break;
-        
+
         //psmsg->timestamp = GetTime();
         //memcpy(&psmsg->timestamp, &now, 8);
         memcpy(&psmsg->nonse[0], &nonse, 4);
-        
+
         for (int i = 0; i < 32; i+=4)
             memcpy(civ+i, &nonse, 4);
-        
+
         unsigned int nBytes;
-        if (!HMAC_Init_ex(&ctx, &civ[0], 32, EVP_sha256(), NULL)
-            || !HMAC_Update(&ctx, (unsigned char*) pHeader+4, SMSG_HDR_LEN-4)
-            || !HMAC_Update(&ctx, (unsigned char*) pPayload, nPayload)
-            || !HMAC_Update(&ctx, pPayload, nPayload)
-            || !HMAC_Final(&ctx, sha256Hash, &nBytes)
-            //|| !HMAC_Final(&ctx, &vchHash[0], &nBytes)
+        if (!HMAC_Init_ex(ctx, &civ[0], 32, EVP_sha256(), NULL)
+            || !HMAC_Update(ctx, (uint8_t*) pHeader+4, SMSG_HDR_LEN-4)
+            || !HMAC_Update(ctx, (uint8_t*) pPayload, nPayload)
+            || !HMAC_Update(ctx, pPayload, nPayload)
+            || !HMAC_Final(ctx, sha256Hash, &nBytes)
+            //|| !HMAC_Final(ctx, &vchHash[0], &nBytes)
             || nBytes != 32)
             break;
-        
+
         /*
         if (CBigNum(vchHash) <= bnTarget)
         {
@@ -3243,7 +3248,7 @@ int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t n
             break;
         };
         */
-        
+
         if (sha256Hash[31] == 0
             && sha256Hash[30] == 0
             && (~(sha256Hash[29]) & ((1<<0) || (1<<1) || (1<<2)) ))
@@ -3254,7 +3259,7 @@ int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t n
             //    printf("Match %u\n", nonse);
             break;
         }
-        
+
         //if (nonse >= UINT32_MAX)
         if (nonse >= 4294967295U)
         {
@@ -3265,44 +3270,49 @@ int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t n
         }    
         nonse++;
     };
-    
-    HMAC_CTX_cleanup(&ctx);
-    
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX_free(ctx);
+#else
+    HMAC_CTX_cleanup(ctx);
+    delete ctx;
+#endif
+
     if (!fSecMsgEnabled)
     {
         if (fDebugSmsg)
             printf("SecureMsgSetHash() stopped, shutdown detected.\n");
         return 2;
     };
-    
+
     if (!found)
     {
         if (fDebugSmsg)
             printf("SecureMsgSetHash() failed, took %" PRI64d" ms, nonse %u\n", GetTimeMillis() - nStart, nonse);
         return 1;
     };
-    
+
     memcpy(psmsg->hash, sha256Hash, 4);
     //memcpy(psmsg->hash, &vchHash[0], 4);
     
     if (fDebugSmsg)
         printf("SecureMsgSetHash() took %" PRI64d" ms, nonse %u\n", GetTimeMillis() - nStart, nonse);
-    
+
     return 0;
 };
 
 int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string& addressTo, std::string& message)
 {
     /* Create a secure message
-        
+
         Using similar method to bitmessage.
         If bitmessage is secure this should be too.
         https://bitmessage.org/wiki/Encryption
-        
+
         Some differences:
         bitmessage seems to use curve sect283r1
         *coin addresses use secp256k1
-        
+
         returns
             2       message is too long.
             3       addressFrom is invalid.
@@ -3315,64 +3325,64 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
             10      Could not generate MAC.
             11      Encrypt failed.
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgEncrypt(%s, %s, ...)\n", addressFrom.c_str(), addressTo.c_str());
-    
-    
+
+
     if (message.size() > SMSG_MAX_MSG_BYTES)
     {
         printf("Message is too long, %" PRIszu".\n", message.size());
         return 2;
     };
-    
+
     smsg.version[0] = 1;
     smsg.version[1] = 1;
     smsg.timestamp = GetTime();
-    
-    
+
+
     bool fSendAnonymous;
     CBitcoinAddress coinAddrFrom;
     CKeyID ckidFrom;
     CKey keyFrom;
-    
+
     if (addressFrom.compare("anon") == 0)
     {
         fSendAnonymous = true;
-        
+
     } else
     {
         fSendAnonymous = false;
-        
+
         if (!coinAddrFrom.SetString(addressFrom))
         {
             printf("addressFrom is not valid.\n");
             return 3;
         };
-        
+
         if (!coinAddrFrom.GetKeyID(ckidFrom))
         {
             printf("coinAddrFrom.GetKeyID failed: %s.\n", coinAddrFrom.ToString().c_str());
             return 3;
         };
     };
-    
-    
+
+
     CBitcoinAddress coinAddrDest;
     CKeyID ckidDest;
-    
+
     if (!coinAddrDest.SetString(addressTo))
     {
         printf("addressTo is not valid.\n");
         return 4;
     };
-    
+
     if (!coinAddrDest.GetKeyID(ckidDest))
     {
         printf("coinAddrDest.GetKeyID failed: %s.\n", coinAddrDest.ToString().c_str());
         return 4;
     };
-    
+
     // -- public key K is the destination address
     CPubKey cpkDestK;
     if (SecureMsgGetStoredKey(ckidDest, cpkDestK) != 0
@@ -3381,18 +3391,18 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
         printf("Could not get public key for destination address.\n");
         return 5;
     };
-    
-    
+
+
     // -- Generate 16 random bytes as IV.
     RandAddSeedPerfmon();
     RAND_bytes(&smsg.iv[0], 16);
-    
-    
+
+
     // -- Generate a new random EC key pair with private key called r and public key called R.
     CKey keyR;
     keyR.MakeNewKey(true); // make compressed key
-    
-    
+
+
     // -- Do an EC point multiply with public key K and private key r. This gives you public key P. 
     CKey keyK;
     if (!keyK.SetPubKey(cpkDestK))
@@ -3400,27 +3410,31 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
         printf("Could not set pubkey for K: %s.\n", ValueString(cpkDestK.Raw()).c_str());
         return 4; // address to is invalid
     };
-    
-    std::vector<unsigned char> vchP;
+
+    std::vector<uint8_t> vchP;
     vchP.resize(32);
     EC_KEY* pkeyr = keyR.GetECKey();
     EC_KEY* pkeyK = keyK.GetECKey();
-    
+
     // always seems to be 32, worth checking?
     //int field_size = EC_GROUP_get_degree(EC_KEY_get0_group(pkeyr));
     //int secret_len = (field_size+7)/8;
     //printf("secret_len %d.\n", secret_len);
-    
+
     // -- ECDH_compute_key returns the same P if fed compressed or uncompressed public keys
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    EC_KEY_set_method(pkeyr, EC_KEY_OpenSSL());
+#else
     ECDH_set_method(pkeyr, ECDH_OpenSSL());
+#endif
     int lenP = ECDH_compute_key(&vchP[0], 32, EC_KEY_get0_public_key(pkeyK), pkeyr, NULL);
-    
+
     if (lenP != 32)
     {
         printf("ECDH_compute_key failed, lenP: %d.\n", lenP);
         return 6;
     };
-    
+
     CPubKey cpkR = keyR.GetPubKey();
     if (!cpkR.IsValid()
         || !cpkR.IsCompressed())
@@ -3428,24 +3442,24 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
         printf("Could not get public key for key R.\n");
         return 1;
     };
-    
+
     memcpy(smsg.cpkR, &cpkR.Raw()[0], 33);
-    
-    
+
+
     // -- Use public key P and calculate the SHA512 hash H.
     //    The first 32 bytes of H are called key_e and the last 32 bytes are called key_m.
-    std::vector<unsigned char> vchHashed;
+    std::vector<uint8_t> vchHashed;
     vchHashed.resize(64); // 512
-    SHA512(&vchP[0], vchP.size(), (unsigned char*)&vchHashed[0]);
-    std::vector<unsigned char> key_e(&vchHashed[0], &vchHashed[0]+32);
-    std::vector<unsigned char> key_m(&vchHashed[32], &vchHashed[32]+32);
+    SHA512(&vchP[0], vchP.size(), (uint8_t*)&vchHashed[0]);
+    std::vector<uint8_t> key_e(&vchHashed[0], &vchHashed[0]+32);
+    std::vector<uint8_t> key_m(&vchHashed[32], &vchHashed[32]+32);
     
     
-    std::vector<unsigned char> vchPayload;
-    std::vector<unsigned char> vchCompressed;
-    unsigned char* pMsgData;
+    std::vector<uint8_t> vchPayload;
+    std::vector<uint8_t> vchCompressed;
+    uint8_t* pMsgData;
     uint32_t lenMsgData;
-    
+
     uint32_t lenMsg = message.size();
     if (lenMsg > 128)
     {
@@ -3457,24 +3471,24 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
             printf("vchCompressed.resize %u threw: %s.\n", worstCase, e.what());
             return 8;
         };
-        
+
         int lenComp = LZ4_compress((char*)message.c_str(), (char*)&vchCompressed[0], lenMsg);
         if (lenComp < 1)
         {
             printf("Could not compress message data.\n");
             return 9;
         };
-        
+
         pMsgData = &vchCompressed[0];
         lenMsgData = lenComp;
-        
+
     } else
     {
         // -- no compression
-        pMsgData = (unsigned char*)message.c_str();
+        pMsgData = (uint8_t*)message.c_str();
         lenMsgData = lenMsg;
     };
-    
+
     if (fSendAnonymous)
     {
         try {
@@ -3483,9 +3497,9 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
             printf("vchPayload.resize %u threw: %s.\n", 9 + lenMsgData, e.what());
             return 8;
         };
-        
+
         memcpy(&vchPayload[9], pMsgData, lenMsgData);
-        
+
         vchPayload[0] = 250; // id as anonymous message
         // -- next 4 bytes are unused - there to ensure encrypted payload always > 8 bytes
         memcpy(&vchPayload[5], &lenMsg, 4); // length of uncompressed plain text
@@ -3504,12 +3518,12 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
             printf("Could not get private key for addressFrom.\n");
             return 7;
         };
-        
+
         // -- sign the plaintext
-        std::vector<unsigned char> vchSignature;
+        std::vector<uint8_t> vchSignature;
         vchSignature.resize(65);
         keyFrom.SignCompact(Hash(message.begin(), message.end()), vchSignature);
-        
+
         // -- Save some bytes by sending address raw
         vchPayload[0] = (static_cast<CBitcoinAddress_B*>(&coinAddrFrom))->getVersion(); // vchPayload[0] = coinAddrDest.nVersion;
         memcpy(&vchPayload[1], (static_cast<CKeyID_B*>(&ckidFrom))->GetPPN(), 20); // memcpy(&vchPayload[1], ckidDest.pn, 20);
@@ -3517,53 +3531,60 @@ int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string&
         memcpy(&vchPayload[1+20], &vchSignature[0], vchSignature.size());
         memcpy(&vchPayload[1+20+65], &lenMsg, 4); // length of uncompressed plain text
     };
-    
-    
+
+
     SecMsgCrypter crypter;
     crypter.SetKey(key_e, smsg.iv);
-    std::vector<unsigned char> vchCiphertext;
-    
+    std::vector<uint8_t> vchCiphertext;
+
     if (!crypter.Encrypt(&vchPayload[0], vchPayload.size(), vchCiphertext))
     {
         printf("crypter.Encrypt failed.\n");
         return 11;
     };
-    
-    try {
-        smsg.pPayload = new unsigned char[vchCiphertext.size()];
-    } catch (std::exception& e)
+
+    try { smsg.pPayload = new uint8_t[vchCiphertext.size()]; } catch (std::exception& e)
     {
         printf("Could not allocate pPayload, exception: %s.\n", e.what());
         return 8;
     };
-    
+
     memcpy(smsg.pPayload, &vchCiphertext[0], vchCiphertext.size());
     smsg.nPayload = vchCiphertext.size();
-    
-    
+
+
     // -- Calculate a 32 byte MAC with HMACSHA256, using key_m as salt
     //    Message authentication code, (hash of timestamp + destination + payload)
     bool fHmacOk = true;
-    unsigned int nBytes = 32;
-    HMAC_CTX ctx;
-    HMAC_CTX_init(&ctx);
-    
-    if (!HMAC_Init_ex(&ctx, &key_m[0], 32, EVP_sha256(), NULL)
-        || !HMAC_Update(&ctx, (unsigned char*) &smsg.timestamp, sizeof(smsg.timestamp))
-        || !HMAC_Update(&ctx, &vchCiphertext[0], vchCiphertext.size())
-        || !HMAC_Final(&ctx, smsg.mac, &nBytes)
+    uint32_t nBytes = 32;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX *ctx = HMAC_CTX_new();
+#else
+    HMAC_CTX *ctx = new HMAC_CTX();
+    HMAC_CTX_init(ctx);
+#endif
+
+    if (!HMAC_Init_ex(ctx, &key_m[0], 32, EVP_sha256(), NULL)
+        || !HMAC_Update(ctx, (uint8_t*) &smsg.timestamp, sizeof(smsg.timestamp))
+        || !HMAC_Update(ctx, &vchCiphertext[0], vchCiphertext.size())
+        || !HMAC_Final(ctx, smsg.mac, &nBytes)
         || nBytes != 32)
         fHmacOk = false;
-    
-    HMAC_CTX_cleanup(&ctx);
-    
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX_free(ctx);
+#else
+    HMAC_CTX_cleanup(ctx);
+    delete ctx;
+#endif
+
     if (!fHmacOk)
     {
         printf("Could not generate MAC.\n");
         return 10;
     };
-    
-    
+
+
     return 0;
 };
 
@@ -3572,19 +3593,19 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
     /* Encrypt secure message, and place it on the network
         Make a copy of the message to sender's first address and place in send queue db
         proof of work thread will pick up messages from  send queue db
-        
+
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgSend(%s, %s, ...)\n", addressFrom.c_str(), addressTo.c_str());
-    
+
     if (pwalletMain->IsLocked())
     {
         sError = "Wallet is locked, wallet must be unlocked to send and recieve messages.";
         printf("Wallet is locked, wallet must be unlocked to send and recieve messages.\n");
         return 1;
     };
-    
+
     if (message.size() > SMSG_MAX_MSG_BYTES)
     {
         std::ostringstream oss;
@@ -3593,15 +3614,15 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
         printf("Message is too long, %" PRIszu".\n", message.size());
         return 1;
     };
-    
-    
+
+
     int rv;
     SecureMessage smsg;
-    
+
     if ((rv = SecureMsgEncrypt(smsg, addressFrom, addressTo, message)) != 0)
     {
         printf("SecureMsgSend(), encrypt for recipient failed.\n");
-        
+
         switch(rv)
         {
             case 2:  sError = "Message is too long.";                       break;
@@ -3619,11 +3640,11 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
         
         return rv;
     };
-    
-    
+
+
     // -- Place message in send queue, proof of work will happen in a thread.
     std::string sPrefix("qm");
-    unsigned char chKey[18];
+    uint8_t chKey[18];
     memcpy(&chKey[0],  sPrefix.data(),  2);
     memcpy(&chKey[2],  &smsg.timestamp, 8);
     memcpy(&chKey[10], &smsg.pPayload,  8);
@@ -3632,7 +3653,7 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
     
     smsgSQ.timeReceived  = GetTime();
     smsgSQ.sAddrTo       = addressTo;
-    
+
     try {
         smsgSQ.vchMessage.resize(SMSG_HDR_LEN + smsg.nPayload);
     } catch (std::exception& e) {
@@ -3640,10 +3661,10 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
         sError = "Could not allocate memory.";
         return 8;
     };
-    
+
     memcpy(&smsgSQ.vchMessage[0], &smsg.hash[0], SMSG_HDR_LEN);
     memcpy(&smsgSQ.vchMessage[SMSG_HDR_LEN], smsg.pPayload, smsg.nPayload);
-    
+
     {
         LOCK(cs_smsgDB);
         SecMsgDB dbSendQueue;
@@ -3653,32 +3674,32 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
             //NotifySecMsgSendQueueChanged(smsgOutbox);
         };
     }
-    
+
     // TODO: only update outbox when proof of work thread is done.
     
     //  -- for outbox create a copy encrypted for owned address
     //     if the wallet is encrypted private key needed to decrypt will be unavailable
-    
+
     if (fDebugSmsg)
         printf("Encrypting message for outbox.\n");
-    
+
     std::string addressOutbox = "None";
     CBitcoinAddress coinAddrOutbox;
-    
+
     BOOST_FOREACH(const PAIRTYPE(CTxDestination, std::string)& entry, pwalletMain->mapAddressBook)
     {
         // -- get first owned address
         if (!IsMine(*pwalletMain, entry.first))
             continue;
-        
+
         const CBitcoinAddress& address = entry.first;
-        
+
         addressOutbox = address.ToString();
         if (!coinAddrOutbox.SetString(addressOutbox)) // test valid
             continue;
         break;
     };
-    
+
     if (addressOutbox == "None")
     {
         printf("Warning: SecureMsgSend() could not find an address to encrypt outbox message with.\n");
@@ -3686,7 +3707,7 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
     {
         if (fDebugSmsg)
             printf("Encrypting a copy for outbox, using address %s\n", addressOutbox.c_str());
-        
+
         SecureMessage smsgForOutbox;
         if ((rv = SecureMsgEncrypt(smsgForOutbox, addressFrom, addressOutbox, message)) != 0)
         {
@@ -3695,17 +3716,17 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
         {
             // -- save sent message to db
             std::string sPrefix("sm");
-            unsigned char chKey[18];
+            uint8_t chKey[18];
             memcpy(&chKey[0],  sPrefix.data(),           2);
             memcpy(&chKey[2],  &smsgForOutbox.timestamp, 8);
             memcpy(&chKey[10], &smsgForOutbox.pPayload,  8);   // sample
-            
+
             SecMsgStored smsgOutbox;
-            
+
             smsgOutbox.timeReceived  = GetTime();
             smsgOutbox.sAddrTo       = addressTo;
             smsgOutbox.sAddrOutbox   = addressOutbox;
-            
+
             try {
                 smsgOutbox.vchMessage.resize(SMSG_HDR_LEN + smsgForOutbox.nPayload);
             } catch (std::exception& e) {
@@ -3715,12 +3736,12 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
             };
             memcpy(&smsgOutbox.vchMessage[0], &smsgForOutbox.hash[0], SMSG_HDR_LEN);
             memcpy(&smsgOutbox.vchMessage[SMSG_HDR_LEN], smsgForOutbox.pPayload, smsgForOutbox.nPayload);
-            
-            
+
+
             {
                 LOCK(cs_smsgDB);
                 SecMsgDB dbSent;
-                
+
                 if (dbSent.Open("cw"))
                 {
                     dbSent.WriteSmesg(chKey, smsgOutbox);
@@ -3729,7 +3750,7 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
             }
         };
     };
-    
+
     if (fDebugSmsg)
         printf("Secure message queued for sending to %s.\n", addressTo.c_str());
     
@@ -3737,42 +3758,42 @@ int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string&
 };
 
 
-int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, MessageData& msg)
+int SecureMsgDecrypt(bool fTestOnly, std::string& address, uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, MessageData& msg)
 {
     /* Decrypt secure message
-        
+
         address is the owned address to decrypt with.
-        
+
         validate first in SecureMsgValidate
-        
+
         returns
             1       Error
             2       Unknown version number
             3       Decrypt address is not valid.
             8       Could not allocate memory
     */
-    
+
     if (fDebugSmsg)
         printf("SecureMsgDecrypt(), using %s, testonly %d.\n", address.c_str(), fTestOnly);
-    
+
     if (!pHeader
         || !pPayload)
     {
         printf("Error: null pointer to header or payload.\n");
         return 1;
     };
-    
+
     SecureMessage* psmsg = (SecureMessage*) pHeader;
-    
-    
+
+
     if (psmsg->version[0] != 1)
     {
         printf("Unknown version number.\n");
         return 2;
     };
-    
-    
-    
+
+
+
     // -- Fetch private key k, used to decrypt
     CBitcoinAddress coinAddrDest;
     CKeyID ckidDest;
@@ -3792,11 +3813,11 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
         printf("Could not get private key for addressDest.\n");
         return 3;
     };
-    
-    
-    
+
+
+
     CKey keyR;
-    std::vector<unsigned char> vchR(psmsg->cpkR, psmsg->cpkR+33); // would be neater to override CPubKey() instead
+    std::vector<uint8_t> vchR(psmsg->cpkR, psmsg->cpkR+33); // would be neater to override CPubKey() instead
     CPubKey cpkR(vchR);
     if (!cpkR.IsValid())
     {
@@ -3808,7 +3829,7 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
         printf("Could not set pubkey for R: %s.\n", ValueString(cpkR.Raw()).c_str());
         return 1;
     };
-    
+
     cpkR = keyR.GetPubKey();
     if (!cpkR.IsValid()
         || !cpkR.IsCompressed())
@@ -3816,80 +3837,93 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
         printf("Could not get compressed public key for key R.\n");
         return 1;
     };
-    
-    
+
+
     // -- Do an EC point multiply with private key k and public key R. This gives you public key P.
-    std::vector<unsigned char> vchP;
+    std::vector<uint8_t> vchP;
     vchP.resize(32);
     EC_KEY* pkeyk = keyDest.GetECKey();
     EC_KEY* pkeyR = keyR.GetECKey();
-    
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    EC_KEY_set_method(pkeyk, EC_KEY_OpenSSL());
+#else
     ECDH_set_method(pkeyk, ECDH_OpenSSL());
+#endif
     int lenPdec = ECDH_compute_key(&vchP[0], 32, EC_KEY_get0_public_key(pkeyR), pkeyk, NULL);
-    
+
     if (lenPdec != 32)
     {
         printf("ECDH_compute_key failed, lenPdec: %d.\n", lenPdec);
         return 1;
     };
-    
-    
+
+
     // -- Use public key P to calculate the SHA512 hash H. 
     //    The first 32 bytes of H are called key_e and the last 32 bytes are called key_m. 
-    std::vector<unsigned char> vchHashedDec;
+    std::vector<uint8_t> vchHashedDec;
     vchHashedDec.resize(64);    // 512 bits
-    SHA512(&vchP[0], vchP.size(), (unsigned char*)&vchHashedDec[0]);
-    std::vector<unsigned char> key_e(&vchHashedDec[0], &vchHashedDec[0]+32);
-    std::vector<unsigned char> key_m(&vchHashedDec[32], &vchHashedDec[32]+32);
-    
-    
+    SHA512(&vchP[0], vchP.size(), (uint8_t*)&vchHashedDec[0]);
+    std::vector<uint8_t> key_e(&vchHashedDec[0], &vchHashedDec[0]+32);
+    std::vector<uint8_t> key_m(&vchHashedDec[32], &vchHashedDec[32]+32);
+
+
     // -- Message authentication code, (hash of timestamp + destination + payload)
-    unsigned char MAC[32];
+    uint8_t MAC[32];
     bool fHmacOk = true;
-    unsigned int nBytes = 32;
-    HMAC_CTX ctx;
-    HMAC_CTX_init(&ctx);
-    
-    if (!HMAC_Init_ex(&ctx, &key_m[0], 32, EVP_sha256(), NULL)
-        || !HMAC_Update(&ctx, (unsigned char*) &psmsg->timestamp, sizeof(psmsg->timestamp))
-        || !HMAC_Update(&ctx, pPayload, nPayload)
-        || !HMAC_Final(&ctx, MAC, &nBytes)
+    uint32_t nBytes = 32;
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX *ctx = HMAC_CTX_new();
+#else
+    HMAC_CTX *ctx = new HMAC_CTX();
+    HMAC_CTX_init(ctx);
+#endif
+
+    if (!HMAC_Init_ex(ctx, &key_m[0], 32, EVP_sha256(), NULL)
+        || !HMAC_Update(ctx, (uint8_t*) &psmsg->timestamp, sizeof(psmsg->timestamp))
+        || !HMAC_Update(ctx, pPayload, nPayload)
+        || !HMAC_Final(ctx, MAC, &nBytes)
         || nBytes != 32)
         fHmacOk = false;
-    
-    HMAC_CTX_cleanup(&ctx);
-    
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L
+    HMAC_CTX_free(ctx);
+#else
+    HMAC_CTX_cleanup(ctx);
+    delete ctx;
+#endif
+
     if (!fHmacOk)
     {
         printf("Could not generate MAC.\n");
         return 1;
     };
-    
+
     if (memcmp(MAC, psmsg->mac, 32) != 0)
     {
         if (fDebugSmsg)
             printf("MAC does not match.\n"); // expected if message is not to address on node
-        
+
         return 1;
     };
-    
+
     if (fTestOnly)
         return 0;
-    
+
     SecMsgCrypter crypter;
     crypter.SetKey(key_e, psmsg->iv);
-    std::vector<unsigned char> vchPayload;
+    std::vector<uint8_t> vchPayload;
     if (!crypter.Decrypt(pPayload, nPayload, vchPayload))
     {
         printf("Decrypt failed.\n");
         return 1;
     };
-    
+
     msg.timestamp = psmsg->timestamp;
     uint32_t lenData;
     uint32_t lenPlain;
-    
-    unsigned char* pMsgData;
+
+    uint8_t* pMsgData;
     bool fFromAnonymous;
     if ((uint32_t)vchPayload[0] == 250)
     {
@@ -3904,15 +3938,15 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
         memcpy(&lenPlain, &vchPayload[1+20+65], 4);
         pMsgData = &vchPayload[SMSG_PL_HDR_LEN];
     };
-    
+
     try {
         msg.vchMessage.resize(lenPlain + 1);
     } catch (std::exception& e) {
         printf("msg.vchMessage.resize %u threw: %s.\n", lenPlain + 1, e.what());
         return 8;
     };
-    
-    
+
+
     if (lenPlain > 128)
     {
         // -- decompress
@@ -3926,20 +3960,20 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
         // -- plaintext
         memcpy(&msg.vchMessage[0], pMsgData, lenPlain);
     };
-    
+
     msg.vchMessage[lenPlain] = '\0';
-    
+
     if (fFromAnonymous)
     {
         // -- Anonymous sender
         msg.sFromAddress = "anon";
     } else
     {
-        std::vector<unsigned char> vchUint160;
+        std::vector<uint8_t> vchUint160;
         vchUint160.resize(20);
-        
+
         memcpy(&vchUint160[0], &vchPayload[1], 20);
-        
+
         uint160 ui160(vchUint160);
         CKeyID ckidFrom(ui160);
         
@@ -3951,7 +3985,7 @@ int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeade
             return 1;
         };
         
-        std::vector<unsigned char> vchSig;
+        std::vector<uint8_t> vchSig;
         vchSig.resize(65);
         
         memcpy(&vchSig[0], &vchPayload[1+20], 65);
diff --git a/src/smessage.h b/src/smessage.h
index 0e8ef37..77a5481 100644
--- a/src/smessage.h
+++ b/src/smessage.h
@@ -64,7 +64,6 @@ extern CCriticalSection cs_smsg;            // all except inbox and outbox
 extern CCriticalSection cs_smsgDB;
 
 
-
 #pragma pack(push, 1)
 class SecureMessage
 {
@@ -74,25 +73,25 @@ public:
         nPayload = 0;
         pPayload = NULL;
     };
-    
+
     ~SecureMessage()
     {
         if (pPayload)
             delete[] pPayload;
         pPayload = NULL;
     };
-    
-    unsigned char   hash[4];
-    unsigned char   version[2];
-    unsigned char   flags;
-    int64_t         timestamp;
-    unsigned char   iv[16];
-    unsigned char   cpkR[33];
-    unsigned char   mac[32];
-    unsigned char   nonse[4];
-    uint32_t        nPayload;
-    unsigned char*  pPayload;
-        
+
+    uint8_t   hash[4];
+    uint8_t   version[2];
+    uint8_t   flags;
+    int64_t   timestamp;
+    uint8_t   iv[16];
+    uint8_t   cpkR[33];
+    uint8_t   mac[32];
+    uint8_t   nonse[4];
+    uint32_t  nPayload;
+    uint8_t*  pPayload;
+
 };
 #pragma pack(pop)
 
@@ -101,31 +100,31 @@ class MessageData
 {
 // -- Decrypted SecureMessage data
 public:
-    int64_t                     timestamp;
-    std::string                 sToAddress;
-    std::string                 sFromAddress;
-    std::vector<unsigned char>  vchMessage;         // null terminated plaintext
+    int64_t               timestamp;
+    std::string           sToAddress;
+    std::string           sFromAddress;
+    std::vector<uint8_t>  vchMessage;         // null terminated plaintext
 };
 
 
 class SecMsgToken
 {
 public:
-    SecMsgToken(int64_t ts, unsigned char* p, int np, long int o)
+    SecMsgToken(int64_t ts, uint8_t* p, int np, long int o)
     {
         timestamp = ts;
-        
+
         if (np < 8) // payload will always be > 8, just make sure
             memset(sample, 0, 8);
         else
             memcpy(sample, p, 8);
         offset = o;
     };
-    
+
     SecMsgToken() {};
-    
+
     ~SecMsgToken() {};
-    
+
     bool operator <(const SecMsgToken& y) const
     {
         // pack and memcmp from timesent?
@@ -133,11 +132,11 @@ public:
             return memcmp(sample, y.sample, 8) < 0;
         return timestamp < y.timestamp;
     }
-    
-    int64_t                     timestamp;    // doesn't need to be full 64 bytes?
-    unsigned char               sample[8];    // first 8 bytes of payload - a hash
-    int64_t                     offset;       // offset
-    
+
+    int64_t               timestamp;    // doesn't need to be full 64 bytes?
+    uint8_t               sample[8];    // first 8 bytes of payload - a hash
+    int64_t               offset;       // offset
+
 };
 
 
@@ -152,15 +151,15 @@ public:
         nLockPeerId     = 0;
     };
     ~SecMsgBucket() {};
-    
+
     void hashBucket();
-    
+
     int64_t                     timeChanged;
     uint32_t                    hash;           // token set should get ordered the same on each node
     uint32_t                    nLockCount;     // set when smsgWant first sent, unset at end of smsgMsg, ticks down in ThreadSecureMsg()
     uint32_t                    nLockPeerId;    // id of peer that bucket is locked for
     std::set<SecMsgToken>       setTokens;
-    
+
 };
 
 
@@ -168,7 +167,7 @@ public:
 class CBitcoinAddress_B : public CBitcoinAddress
 {
 public:
-    unsigned char getVersion()
+    uint8_t getVersion()
     {
         return nVersion;
     }
@@ -194,11 +193,11 @@ public:
         fReceiveEnabled     = receiveOn;
         fReceiveAnon        = receiveAnon;
     };
-    
+
     std::string     sAddress;
     bool            fReceiveEnabled;
     bool            fReceiveAnon;
-    
+
     IMPLEMENT_SERIALIZE
     (
         READWRITE(this->sAddress);
@@ -216,7 +215,7 @@ public:
         fNewAddressRecv = true;
         fNewAddressAnon = true;
     }
-    
+
     bool fNewAddressRecv;
     bool fNewAddressAnon;
 };
@@ -225,11 +224,11 @@ public:
 class SecMsgCrypter
 {
 private:
-    unsigned char chKey[32];
-    unsigned char chIV[16];
+    uint8_t chKey[32];
+    uint8_t chIV[16];
     bool fKeySet;
 public:
-    
+
     SecMsgCrypter()
     {
         // Try to keep the key data out of swap (and be a bit over-careful to keep the IV that we don't even use out of swap)
@@ -239,35 +238,35 @@ public:
         LockedPageManager::instance.LockRange(&chIV[0], sizeof chIV);
         fKeySet = false;
     }
-    
+
     ~SecMsgCrypter()
     {
         // clean key
         memset(&chKey, 0, sizeof chKey);
         memset(&chIV, 0, sizeof chIV);
         fKeySet = false;
-        
+
         LockedPageManager::instance.UnlockRange(&chKey[0], sizeof chKey);
         LockedPageManager::instance.UnlockRange(&chIV[0], sizeof chIV);
     }
-    
-    bool SetKey(const std::vector<unsigned char>& vchNewKey, unsigned char* chNewIV);
-    bool SetKey(const unsigned char* chNewKey, unsigned char* chNewIV);
-    bool Encrypt(unsigned char* chPlaintext, uint32_t nPlain, std::vector<unsigned char> &vchCiphertext);
-    bool Decrypt(unsigned char* chCiphertext, uint32_t nCipher, std::vector<unsigned char>& vchPlaintext);
+
+    bool SetKey(const std::vector<uint8_t>& vchNewKey, uint8_t* chNewIV);
+    bool SetKey(const uint8_t* chNewKey, uint8_t* chNewIV);
+    bool Encrypt(uint8_t* chPlaintext, uint32_t nPlain, std::vector<uint8_t> &vchCiphertext);
+    bool Decrypt(uint8_t* chCiphertext, uint32_t nCipher, std::vector<uint8_t>& vchPlaintext);
 };
 
 
 class SecMsgStored
 {
 public:
-    int64_t                         timeReceived;
-    char                            status;         // read etc
-    uint16_t                        folderId;
-    std::string                     sAddrTo;        // when in owned addr, when sent remote addr
-    std::string                     sAddrOutbox;    // owned address this copy was encrypted with
-    std::vector<unsigned char>      vchMessage;     // message header + encryped payload
-    
+    int64_t                   timeReceived;
+    char                      status;         // read etc
+    uint16_t                  folderId;
+    std::string               sAddrTo;        // when in owned addr, when sent remote addr
+    std::string               sAddrOutbox;    // owned address this copy was encrypted with
+    std::vector<uint8_t>      vchMessage;     // message header + encryped payload
+
     IMPLEMENT_SERIALIZE
     (
         READWRITE(this->timeReceived);
@@ -286,43 +285,42 @@ public:
     {
         activeBatch = NULL;
     };
-    
+
     ~SecMsgDB()
     {
         // -- deletes only data scoped to this TxDB object.
-        
+
         if (activeBatch)
             delete activeBatch;
     };
-    
+
     bool Open(const char* pszMode="r+");
-    
+
     bool ScanBatch(const CDataStream& key, std::string* value, bool* deleted) const;
-    
+
     bool TxnBegin();
     bool TxnCommit();
     bool TxnAbort();
-    
+
     bool ReadPK(CKeyID& addr, CPubKey& pubkey);
     bool WritePK(CKeyID& addr, CPubKey& pubkey);
     bool ExistsPK(CKeyID& addr);
-    
-    bool NextSmesg(leveldb::Iterator* it, std::string& prefix, unsigned char* vchKey, SecMsgStored& smsgStored);
-    bool NextSmesgKey(leveldb::Iterator* it, std::string& prefix, unsigned char* vchKey);
-    bool ReadSmesg(unsigned char* chKey, SecMsgStored& smsgStored);
-    bool WriteSmesg(unsigned char* chKey, SecMsgStored& smsgStored);
-    bool ExistsSmesg(unsigned char* chKey);
-    bool EraseSmesg(unsigned char* chKey);
-    
+
+    bool NextSmesg(leveldb::Iterator* it, std::string& prefix, uint8_t* vchKey, SecMsgStored& smsgStored);
+    bool NextSmesgKey(leveldb::Iterator* it, std::string& prefix, uint8_t* vchKey);
+    bool ReadSmesg(uint8_t* chKey, SecMsgStored& smsgStored);
+    bool WriteSmesg(uint8_t* chKey, SecMsgStored& smsgStored);
+    bool ExistsSmesg(uint8_t* chKey);
+    bool EraseSmesg(uint8_t* chKey);
+
     leveldb::DB *pdb;       // points to the global instance
     leveldb::WriteBatch *activeBatch;
-    
+
 };
 
 std::string getTimeString(int64_t timestamp, char *buffer, size_t nBuffer);
 std::string fsReadable(uint64_t nBytes);
 
-
 int SecureMsgBuildBucketSet();
 int SecureMsgAddWalletAddresses();
 
@@ -348,7 +346,7 @@ bool SecureMsgScanBuckets();
 int SecureMsgWalletUnlocked();
 int SecureMsgWalletKeyChanged(std::string sAddress, std::string sLabel, ChangeType mode);
 
-int SecureMsgScanMessage(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, bool reportToGui);
+int SecureMsgScanMessage(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, bool reportToGui);
 
 int SecureMsgGetStoredKey(CKeyID& ckid, CPubKey& cpkOut);
 int SecureMsgGetLocalKey(CKeyID& ckid, CPubKey& cpkOut);
@@ -356,24 +354,24 @@ int SecureMsgGetLocalPublicKey(std::string& strAddress, std::string& strPublicKe
 
 int SecureMsgAddAddress(std::string& address, std::string& publicKey);
 
-int SecureMsgRetrieve(SecMsgToken &token, std::vector<unsigned char>& vchData);
+int SecureMsgRetrieve(SecMsgToken &token, std::vector<uint8_t>& vchData);
 
-int SecureMsgReceive(CNode* pfrom, std::vector<unsigned char>& vchData);
+int SecureMsgReceive(CNode* pfrom, std::vector<uint8_t>& vchData);
 
-int SecureMsgStoreUnscanned(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload);
-int SecureMsgStore(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, bool fUpdateBucket);
+int SecureMsgStoreUnscanned(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload);
+int SecureMsgStore(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, bool fUpdateBucket);
 int SecureMsgStore(SecureMessage& smsg, bool fUpdateBucket);
 
 
 
 int SecureMsgSend(std::string& addressFrom, std::string& addressTo, std::string& message, std::string& sError);
 
-int SecureMsgValidate(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload);
-int SecureMsgSetHash(unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload);
+int SecureMsgValidate(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload);
+int SecureMsgSetHash(uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload);
 
 int SecureMsgEncrypt(SecureMessage& smsg, std::string& addressFrom, std::string& addressTo, std::string& message);
 
-int SecureMsgDecrypt(bool fTestOnly, std::string& address, unsigned char *pHeader, unsigned char *pPayload, uint32_t nPayload, MessageData& msg);
+int SecureMsgDecrypt(bool fTestOnly, std::string& address, uint8_t *pHeader, uint8_t *pPayload, uint32_t nPayload, MessageData& msg);
 int SecureMsgDecrypt(bool fTestOnly, std::string& address, SecureMessage& smsg, MessageData& msg);
 
 
