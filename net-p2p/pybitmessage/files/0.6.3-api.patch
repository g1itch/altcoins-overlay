diff --git a/setup.py b/setup.py
index e3f97bac..937c148b 100644
--- a/setup.py
+++ b/setup.py
@@ -22,7 +22,8 @@ EXTRAS_REQUIRE = {
         'curses',  # src/depends.py
         'python2-pythondialog',  # src/depends.py
         'm2r',  # fab build_docs
-    ]
+    ],
+    'xml': ['defusedxml']
 }
 
 
diff --git a/src/api.py b/src/api.py
index 1e485209..23fc53dd 100644
--- a/src/api.py
+++ b/src/api.py
@@ -1,34 +1,32 @@
-# pylint: disable=too-many-locals,too-many-lines,no-self-use,too-many-public-methods,too-many-branches
-# pylint: disable=too-many-statements
+# pylint: disable=protected-access,attribute-defined-outside-init,no-member
 """
 src/api.py
 ==========
+"""
 
 # Copyright (c) 2012-2016 Jonathan Warren
 # Copyright (c) 2012-2019 The Bitmessage developers
 
-This is not what you run to run the Bitmessage API. Instead, enable the API
-( https://bitmessage.org/wiki/API ) and optionally enable daemon mode
-( https://bitmessage.org/wiki/Daemon ) then run bitmessagemain.py.
-"""
-
-from __future__ import absolute_import
+# This is not what you run to run the Bitmessage API. Instead, enable the API
+# ( https://bitmessage.org/wiki/API ) and optionally enable daemon mode
+# ( https://bitmessage.org/wiki/Daemon ) then run bitmessagemain.py.
 
 import base64
+import ConfigParser
 import errno
 import hashlib
+import httplib
 import json
 import random  # nosec
 import socket
 import subprocess
 import threading
 import time
+import xmlrpclib
 from binascii import hexlify, unhexlify
 from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler, SimpleXMLRPCServer
 from struct import pack
 
-from version import softwareVersion
-
 import defaults
 import helper_inbox
 import helper_sent
@@ -39,37 +37,34 @@ import queues
 import shared
 import shutdown
 import state
-from addresses import addBMIfNotPresent, calculateInventoryHash, decodeAddress, decodeVarint, varintDecodeError
+from addresses import (
+    addBMIfNotPresent, calculateInventoryHash, decodeAddress, decodeVarint,
+    varintDecodeError
+)
 from bmconfigparser import BMConfigParser
 from debug import logger
 from helper_ackPayload import genAckPayload
 from helper_sql import SqlBulkExecute, sqlExecute, sqlQuery, sqlStoredProcedure
 from inventory import Inventory
+from version import softwareVersion
 
-str_chan = '[chan]'
+try:  # TODO: write tests for XML vulnerabilities
+    from defusedxml.xmlrpc import monkey_patch
+except ImportError:
+    logger.warning(
+        'defusedxml not available, only use API on a secure, closed network.')
+else:
+    monkey_patch()
 
 
-class APIError(Exception):
-    """APIError exception class"""
+str_chan = '[chan]'
+str_broadcast_subscribers = '[Broadcast subscribers]'
 
-    def __init__(self, error_number, error_message):
-        super(APIError, self).__init__()
-        self.error_number = error_number
-        self.error_message = error_message
 
+class APIError(xmlrpclib.Fault):
+    """APIError exception class"""
     def __str__(self):
-        return "API Error %04i: %s" % (self.error_number, self.error_message)
-
-
-class StoppableXMLRPCServer(SimpleXMLRPCServer):
-    """A SimpleXMLRPCServer that honours state.shutdown"""
-    allow_reuse_address = True
-
-    def serve_forever(self):
-        """Start the SimpleXMLRPCServer"""
-        # pylint: disable=arguments-differ
-        while state.shutdown == 0:
-            self.handle_request()
+        return "API Error %04i: %s" % (self.faultCode, self.faultString)
 
 
 # This thread, of which there is only one, runs the API.
@@ -98,15 +93,40 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
             getattr(errno, 'WSAEADDRINUSE')
         except AttributeError:
             errno.WSAEADDRINUSE = errno.EADDRINUSE
+
+        RPCServerBase = SimpleXMLRPCServer
+        ct = 'text/xml'
+        if BMConfigParser().safeGet(
+                'bitmessagesettings', 'apivariant') == 'json':
+            try:
+                from jsonrpclib.SimpleJSONRPCServer import (
+                    SimpleJSONRPCServer as RPCServerBase)
+            except ImportError:
+                logger.warning(
+                    'jsonrpclib not available, failing back to XML-RPC')
+            else:
+                ct = 'application/json-rpc'
+
+        # Nested class. FIXME not found a better solution.
+        class StoppableRPCServer(RPCServerBase):
+            """A SimpleXMLRPCServer that honours state.shutdown"""
+            allow_reuse_address = True
+            content_type = ct
+
+            def serve_forever(self, poll_interval=None):
+                """Start the RPCServer"""
+                while state.shutdown == 0:
+                    self.handle_request()
+
         for attempt in range(50):
             try:
                 if attempt > 0:
                     port = random.randint(32767, 65535)
-                se = StoppableXMLRPCServer(
+                se = StoppableRPCServer(
                     (BMConfigParser().get(
                         'bitmessagesettings', 'apiinterface'),
                      port),
-                    MySimpleXMLRPCRequestHandler, True, True)
+                    BMXMLRPCRequestHandler, True, encoding='UTF-8')
             except socket.error as e:
                 if e.errno in (errno.EADDRINUSE, errno.WSAEADDRINUSE):
                     continue
@@ -116,6 +136,8 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
                         "bitmessagesettings", "apiport", str(port))
                     BMConfigParser().save()
                 break
+
+        se.register_instance(BMRPCDispatcher())
         se.register_introspection_functions()
 
         apiNotifyPath = BMConfigParser().safeGet(
@@ -135,13 +157,58 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
         se.serve_forever()
 
 
-class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
+class CommandHandler(type):
     """
-    This is one of several classes that constitute the API
-
-    This class was written by Vaibhav Bhatia.  Modified by Jonathan Warren (Atheros).
-    http://code.activestate.com/recipes/501148-xmlrpc-serverclient-which-does-cookie-handling-and/
+    The metaclass for singleAPI which fills _handlers dict by methods
+    decorated with @command
     """
+    def __new__(mcs, name, bases, namespace):
+        result = super(CommandHandler, mcs).__new__(
+            mcs, name, bases, namespace)
+        result.config = BMConfigParser()
+        result._handlers = {}
+        apivariant = result.config.safeGet('bitmessagesettings', 'apivariant')
+        for func in namespace.values():
+            try:
+                for alias in getattr(func, '_cmd'):
+                    try:
+                        prefix, alias = alias.split(':')
+                        if apivariant != prefix:
+                            continue
+                    except ValueError:
+                        pass
+                    result._handlers[alias] = func
+            except AttributeError:
+                pass
+        return result
+
+
+class command(object):
+    """Decorator for API command method"""
+    def __init__(self, *aliases):
+        self.aliases = aliases
+
+    def __call__(self, func):
+        if BMConfigParser().safeGet(
+                'bitmessagesettings', 'apivariant') == 'legacy':
+            def wrapper(*args):
+                result = func(*args)
+                return result if isinstance(result, (int, str)) \
+                    else json.dumps(result, indent=4)
+            wrapper.__doc__ = func.__doc__
+        else:
+            wrapper = func
+        wrapper._cmd = self.aliases
+        return wrapper
+
+
+# This is one of several classes that constitute the API
+# This class was written by Vaibhav Bhatia.
+# Modified by Jonathan Warren (Atheros).
+# Further modified by the Bitmessage developers
+# http://code.activestate.com/recipes/501148
+class BMXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
+    """The main API handler"""
 
     def do_POST(self):
         """
@@ -173,22 +240,34 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 size_remaining -= len(L[-1])
             data = ''.join(L)
 
-            # In previous versions of SimpleXMLRPCServer, _dispatch
-            # could be overridden in this class, instead of in
-            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
-            # check to see if a subclass implements _dispatch and dispatch
-            # using that method if present.
-            response = self.server._marshaled_dispatch(  # pylint: disable=protected-access
-                data, getattr(self, '_dispatch', None)
-            )
-        except BaseException:  # This should only happen if the module is buggy
+            self.cookies = []
+
+            validuser = self.APIAuthenticateClient()
+            if not validuser:
+                time.sleep(2)
+                self.send_response(httplib.UNAUTHORIZED)
+                self.end_headers()
+                return
+                # "RPC Username or password incorrect or HTTP header"
+                # " lacks authentication at all."
+            else:
+                # In previous versions of SimpleXMLRPCServer, _dispatch
+                # could be overridden in this class, instead of in
+                # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
+                # check to see if a subclass implements _dispatch and dispatch
+                # using that method if present.
+                # pylint: disable=protected-access
+                response = self.server._marshaled_dispatch(
+                    data, getattr(self, '_dispatch', None)
+                )
+        except Exception:  # This should only happen if the module is buggy
             # internal error, report as HTTP server error
-            self.send_response(500)
+            self.send_response(httplib.INTERNAL_SERVER_ERROR)
             self.end_headers()
         else:
             # got a valid XML RPC response
-            self.send_response(200)
-            self.send_header("Content-type", "text/xml")
+            self.send_response(httplib.OK)
+            self.send_header("Content-type", self.server.content_type)
             self.send_header("Content-length", str(len(response)))
 
             # HACK :start -> sends cookies here
@@ -204,16 +283,24 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             self.wfile.flush()
             self.connection.shutdown(1)
 
+            # actually handle shutdown command after sending response
+            if state.shutdown is False:
+                shutdown.doCleanShutdown()
+
     def APIAuthenticateClient(self):
-        """Predicate to check for valid API credentials in the request header"""
+        """
+        Predicate to check for valid API credentials in the request header
+        """
 
         if 'Authorization' in self.headers:
             # handle Basic authentication
-            _, encstr = self.headers.get('Authorization').split()
+            encstr = self.headers.get('Authorization').split()[1]
             emailid, password = encstr.decode('base64').split(':')
             return (
-                emailid == BMConfigParser().get('bitmessagesettings', 'apiusername') and
-                password == BMConfigParser().get('bitmessagesettings', 'apipassword')
+                emailid == BMConfigParser().get(
+                    'bitmessagesettings', 'apiusername') and
+                password == BMConfigParser().get(
+                    'bitmessagesettings', 'apipassword')
             )
         else:
             logger.warning(
@@ -223,6 +310,11 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
 
         return False
 
+
+class BMRPCDispatcher(object):
+    """This class is used to dispatch API commands"""
+    __metaclass__ = CommandHandler
+
     def _decode(self, text, decode_type):
         try:
             if decode_type == 'hex':
@@ -231,7 +323,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 return base64.b64decode(text)
         except Exception as e:
             raise APIError(
-                22, "Decode error - %s. Had trouble while decoding string: %r"
+                22, 'Decode error - %s. Had trouble while decoding string: %r'
                 % (e, text)
             )
         return None
@@ -240,20 +332,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         status, addressVersionNumber, streamNumber, ripe = \
             decodeAddress(address)
         if status != 'success':
-            logger.warning(
-                'API Error 0007: Could not decode address %s. Status: %s.',
-                address, status
-            )
-
             if status == 'checksumfailed':
                 raise APIError(8, 'Checksum failed for address: ' + address)
             if status == 'invalidcharacters':
                 raise APIError(9, 'Invalid characters in address: ' + address)
             if status == 'versiontoohigh':
-                raise APIError(10, 'Address version number too high (or zero) in address: ' + address)
+                raise APIError(
+                    10,
+                    'Address version number too high (or zero) in address: ' +
+                    address)
             if status == 'varintmalformed':
                 raise APIError(26, 'Malformed varint in address: ' + address)
-            raise APIError(7, 'Could not decode address: %s : %s' % (address, status))
+            raise APIError(
+                7, 'Could not decode address: %s : %s' % (address, status))
         if addressVersionNumber < 2 or addressVersionNumber > 4:
             raise APIError(
                 11, 'The address version number currently must be 2, 3 or 4.'
@@ -265,71 +356,93 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 ' Check the address.'
             )
 
-        return (status, addressVersionNumber, streamNumber, ripe)
+        return {
+            'status': status,
+            'addressVersion': addressVersionNumber,
+            'streamNumber': streamNumber,
+            'ripe': base64.b64encode(ripe)
+        } if self._method == 'decodeAddress' else (
+            status, addressVersionNumber, streamNumber, ripe)
+
+    def _dump_inbox_message(
+            self, msgid, toAddress, fromAddress, subject, received,
+            message, encodingtype, read):
+        subject = shared.fixPotentiallyInvalidUTF8Data(subject)
+        message = shared.fixPotentiallyInvalidUTF8Data(message)
+        return {
+            'msgid': hexlify(msgid),
+            'toAddress': toAddress,
+            'fromAddress': fromAddress,
+            'subject': base64.b64encode(subject),
+            'message': base64.b64encode(message),
+            'encodingType': encodingtype,
+            'receivedTime': received,
+            'read': read
+        }
+
+    def _dump_sent_message(
+            self, msgid, toAddress, fromAddress, subject, lastactiontime,
+            message, encodingtype, status, ackdata):
+        subject = shared.fixPotentiallyInvalidUTF8Data(subject)
+        message = shared.fixPotentiallyInvalidUTF8Data(message)
+        return {
+            'msgid': hexlify(msgid),
+            'toAddress': toAddress,
+            'fromAddress': fromAddress,
+            'subject': base64.b64encode(subject),
+            'message': base64.b64encode(message),
+            'encodingType': encodingtype,
+            'lastActionTime': lastactiontime,
+            'status': status,
+            'ackData': hexlify(ackdata)
+        }
 
     # Request Handlers
 
-    def HandleListAddresses(self, method):
-        """Handle a request to list addresses"""
-
-        data = '{"addresses":['
-        for addressInKeysFile in BMConfigParser().addresses():
-            status, addressVersionNumber, streamNumber, hash01 = decodeAddress(  # pylint: disable=unused-variable
-                addressInKeysFile)
-            if len(data) > 20:
-                data += ','
-            if BMConfigParser().has_option(addressInKeysFile, 'chan'):
-                chan = BMConfigParser().getboolean(addressInKeysFile, 'chan')
-            else:
-                chan = False
-            label = BMConfigParser().get(addressInKeysFile, 'label')
-            if method == 'listAddresses2':
+    @command('decodeAddress')
+    def HandleDecodeAddress(self, address):
+        return self._verifyAddress(address)
+
+    @command('listAddresses', 'listAddresses2')
+    def HandleListAddresses(self):
+        data = []
+        for address in self.config.addresses():
+            streamNumber = decodeAddress(address)[2]
+            label = self.config.get(address, 'label')
+            if self._method == 'listAddresses2':
                 label = base64.b64encode(label)
-            data += json.dumps({
+            data.append({
                 'label': label,
-                'address': addressInKeysFile,
+                'address': address,
                 'stream': streamNumber,
-                'enabled':
-                BMConfigParser().getboolean(addressInKeysFile, 'enabled'),
-                'chan': chan
-            }, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleListAddressBookEntries(self, params):
-        """Handle a request to list address book entries"""
-
-        if len(params) == 1:
-            label, = params
-            label = self._decode(label, "base64")
-            queryreturn = sqlQuery(
-                "SELECT label, address from addressbook WHERE label = ?",
-                label)
-        elif len(params) > 1:
-            raise APIError(0, "Too many paremeters, max 1")
-        else:
-            queryreturn = sqlQuery("SELECT label, address from addressbook")
-        data = '{"addresses":['
-        for row in queryreturn:
-            label, address = row
+                'enabled': self.config.safeGetBoolean(address, 'enabled'),
+                'chan': self.config.safeGetBoolean(address, 'chan')
+            })
+        return {'addresses': data}
+
+    # the listAddressbook alias should be removed eventually.
+    @command('listAddressBookEntries', 'legacy:listAddressbook')
+    def HandleListAddressBookEntries(self, label=None):
+        queryreturn = sqlQuery(
+            "SELECT label, address from addressbook WHERE label = ?",
+            label
+        ) if label else sqlQuery("SELECT label, address from addressbook")
+        data = []
+        for label, address in queryreturn:
             label = shared.fixPotentiallyInvalidUTF8Data(label)
-            if len(data) > 20:
-                data += ','
-            data += json.dumps({
+            data.append({
                 'label': base64.b64encode(label),
-                'address': address}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleAddAddressBookEntry(self, params):
-        """Handle a request to add an address book entry"""
+                'address': address
+            })
+        return {'addresses': data}
 
-        if len(params) != 2:
-            raise APIError(0, "I need label and address")
-        address, label = params
+    # the addAddressbook alias should be deleted eventually.
+    @command('addAddressBookEntry', 'legacy:addAddressbook')
+    def HandleAddAddressBookEntry(self, address, label):
         label = self._decode(label, "base64")
         address = addBMIfNotPresent(address)
         self._verifyAddress(address)
+        # TODO: add unique together constraint in the table
         queryreturn = sqlQuery(
             "SELECT address FROM addressbook WHERE address=?", address)
         if queryreturn != []:
@@ -342,12 +455,9 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderAddressBook', ''))
         return "Added address %s to address book" % address
 
-    def HandleDeleteAddressBookEntry(self, params):
-        """Handle a request to delete an address book entry"""
-
-        if len(params) != 1:
-            raise APIError(0, "I need an address")
-        address, = params
+    # the deleteAddressbook alias should be deleted eventually.
+    @command('deleteAddressBookEntry', 'legacy:deleteAddressbook')
+    def HandleDeleteAddressBookEntry(self, address):
         address = addBMIfNotPresent(address)
         self._verifyAddress(address)
         sqlExecute('DELETE FROM addressbook WHERE address=?', address)
@@ -356,46 +466,35 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderAddressBook', ''))
         return "Deleted address book entry for %s if it existed" % address
 
-    def HandleCreateRandomAddress(self, params):
+    @command('createRandomAddress')
+    def HandleCreateRandomAddress(
+        self, label, eighteenByteRipe=False, totalDifficulty=0,
+        smallMessageDifficulty=0
+    ):
         """Handle a request to create a random address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 1:
-            label, = params
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 2:
-            label, eighteenByteRipe = params
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 3:
-            label, eighteenByteRipe, totalDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 4:
-            label, eighteenByteRipe, totalDifficulty, \
-                smallMessageDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = int(
-                defaults.networkDefaultPayloadLengthExtraBytes * smallMessageDifficulty)
-        else:
-            raise APIError(0, 'Too many parameters!')
+        nonceTrialsPerByte = self.config.get(
+            'bitmessagesettings', 'defaultnoncetrialsperbyte'
+        ) if not totalDifficulty else int(
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte *
+            totalDifficulty)
+        payloadLengthExtraBytes = self.config.get(
+            'bitmessagesettings', 'defaultpayloadlengthextrabytes'
+        ) if not smallMessageDifficulty else int(
+            defaults.networkDefaultPayloadLengthExtraBytes *
+            smallMessageDifficulty)
+
+        if not isinstance(eighteenByteRipe, bool):
+            raise APIError(
+                23, 'Bool expected in eighteenByteRipe, saw %s instead' %
+                type(eighteenByteRipe))
         label = self._decode(label, "base64")
         try:
             unicode(label, 'utf-8')
-        except BaseException:
+        except UnicodeDecodeError:
             raise APIError(17, 'Label is not valid UTF-8 data.')
         queues.apiAddressGeneratorReturnQueue.queue.clear()
+        # FIXME hard coded stream no
         streamNumberForAddress = 1
         queues.addressGeneratorQueue.put((
             'createRandomAddress', 4, streamNumberForAddress, label, 1, "",
@@ -403,77 +502,25 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         ))
         return queues.apiAddressGeneratorReturnQueue.get()
 
-    def HandleCreateDeterministicAddresses(self, params):
+    @command('createDeterministicAddresses')
+    def HandleCreateDeterministicAddresses(
+        self, passphrase, numberOfAddresses=1, addressVersionNumber=0,
+        streamNumber=0, eighteenByteRipe=False, totalDifficulty=0,
+        smallMessageDifficulty=0
+    ):
         """Handle a request to create a deterministic address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 1:
-            passphrase, = params
-            numberOfAddresses = 1
-            addressVersionNumber = 0
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 2:
-            passphrase, numberOfAddresses = params
-            addressVersionNumber = 0
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 3:
-            passphrase, numberOfAddresses, addressVersionNumber = params
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 4:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber = params
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 5:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe = params
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 6:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe, totalDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 7:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe, totalDifficulty, \
-                smallMessageDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = int(
-                defaults.networkDefaultPayloadLengthExtraBytes * smallMessageDifficulty)
-        else:
-            raise APIError(0, 'Too many parameters!')
+        nonceTrialsPerByte = self.config.get(
+            'bitmessagesettings', 'defaultnoncetrialsperbyte'
+        ) if not totalDifficulty else int(
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte *
+            totalDifficulty)
+        payloadLengthExtraBytes = self.config.get(
+            'bitmessagesettings', 'defaultpayloadlengthextrabytes'
+        ) if not smallMessageDifficulty else int(
+            defaults.networkDefaultPayloadLengthExtraBytes *
+            smallMessageDifficulty)
+
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         if not isinstance(eighteenByteRipe, bool):
@@ -484,13 +531,13 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # 0 means "just use the proper addressVersionNumber"
         if addressVersionNumber == 0:
             addressVersionNumber = 4
-        if addressVersionNumber != 3 and addressVersionNumber != 4:
+        if addressVersionNumber not in (3, 4):
             raise APIError(
                 2, 'The address version number currently must be 3, 4, or 0'
                 ' (which means auto-select). %i isn\'t supported.' %
                 addressVersionNumber)
         if streamNumber == 0:  # 0 means "just use the most available stream"
-            streamNumber = 1
+            streamNumber = 1  # FIXME hard coded stream no
         if streamNumber != 1:
             raise APIError(
                 3, 'The stream number must be 1 (or 0 which means'
@@ -515,27 +562,20 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             'unused API address', numberOfAddresses, passphrase,
             eighteenByteRipe, nonceTrialsPerByte, payloadLengthExtraBytes
         ))
-        data = '{"addresses":['
-        queueReturn = queues.apiAddressGeneratorReturnQueue.get()
-        for item in queueReturn:
-            if len(data) > 20:
-                data += ','
-            data += "\"" + item + "\""
-        data += ']}'
-        return data
-
-    def HandleGetDeterministicAddress(self, params):
+
+        return {'addresses': queues.apiAddressGeneratorReturnQueue.get()}
+
+    @command('getDeterministicAddress')
+    def HandleGetDeterministicAddress(
+            self, passphrase, addressVersionNumber, streamNumber):
         """Handle a request to get a deterministic address"""
 
-        if len(params) != 3:
-            raise APIError(0, 'I need exactly 3 parameters.')
-        passphrase, addressVersionNumber, streamNumber = params
         numberOfAddresses = 1
         eighteenByteRipe = False
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         passphrase = self._decode(passphrase, "base64")
-        if addressVersionNumber != 3 and addressVersionNumber != 4:
+        if addressVersionNumber not in (3, 4):
             raise APIError(
                 2, 'The address version number currently must be 3 or 4. %i'
                 ' isn\'t supported.' % addressVersionNumber)
@@ -553,16 +593,11 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         ))
         return queues.apiAddressGeneratorReturnQueue.get()
 
-    def HandleCreateChan(self, params):
+    @command('createChan')
+    def HandleCreateChan(self, passphrase):
         """Handle a request to create a chan"""
 
-        if not params:
-            raise APIError(0, 'I need parameters.')
-
-        elif len(params) == 1:
-            passphrase, = params
         passphrase = self._decode(passphrase, "base64")
-
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         # It would be nice to make the label the passphrase but it is
@@ -570,7 +605,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         try:
             unicode(passphrase, 'utf-8')
             label = str_chan + ' ' + passphrase
-        except BaseException:
+        except UnicodeDecodeError:
             label = str_chan + ' ' + repr(passphrase)
 
         addressVersionNumber = 4
@@ -583,18 +618,15 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             passphrase, True
         ))
         queueReturn = queues.apiAddressGeneratorReturnQueue.get()
-        if not queueReturn:
+        try:
+            return queueReturn[0]
+        except IndexError:
             raise APIError(24, 'Chan address is already present.')
-        address = queueReturn[0]
-        return address
 
-    def HandleJoinChan(self, params):
+    @command('joinChan')
+    def HandleJoinChan(self, passphrase, suppliedAddress):
         """Handle a request to join a chan"""
 
-        if len(params) < 2:
-            raise APIError(0, 'I need two parameters.')
-        elif len(params) == 2:
-            passphrase, suppliedAddress = params
         passphrase = self._decode(passphrase, "base64")
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
@@ -603,121 +635,88 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         try:
             unicode(passphrase, 'utf-8')
             label = str_chan + ' ' + passphrase
-        except BaseException:
+        except UnicodeDecodeError:
             label = str_chan + ' ' + repr(passphrase)
 
-        status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(  # pylint: disable=unused-variable
-            suppliedAddress)
+        self._verifyAddress(suppliedAddress)
         suppliedAddress = addBMIfNotPresent(suppliedAddress)
         queues.apiAddressGeneratorReturnQueue.queue.clear()
         queues.addressGeneratorQueue.put((
             'joinChan', suppliedAddress, label, passphrase, True
         ))
-        addressGeneratorReturnValue = \
-            queues.apiAddressGeneratorReturnQueue.get()
-
-        if addressGeneratorReturnValue[0] == \
-                'chan name does not match address':
-            raise APIError(18, 'Chan name does not match address.')
-        if not addressGeneratorReturnValue:
+        queueReturn = queues.apiAddressGeneratorReturnQueue.get()
+        try:
+            if queueReturn[0] == 'chan name does not match address':
+                raise APIError(18, 'Chan name does not match address.')
+        except IndexError:
             raise APIError(24, 'Chan address is already present.')
+
         return "success"
 
-    def HandleLeaveChan(self, params):
+    @command('leaveChan')
+    def HandleLeaveChan(self, address):
         """Handle a request to leave a chan"""
-
-        if not params:
-            raise APIError(0, 'I need parameters.')
-        elif len(params) == 1:
-            address, = params
-            # pylint: disable=unused-variable
-            status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(address)
+        self._verifyAddress(address)
         address = addBMIfNotPresent(address)
-        if not BMConfigParser().has_section(address):
-            raise APIError(
-                13, 'Could not find this address in your keys.dat file.')
-        if not BMConfigParser().safeGetBoolean(address, 'chan'):
+        if not self.config.safeGetBoolean(address, 'chan'):
             raise APIError(
                 25, 'Specified address is not a chan address.'
                 ' Use deleteAddress API call instead.')
-        BMConfigParser().remove_section(address)
-        with open(state.appdata + 'keys.dat', 'wb') as configfile:
-            BMConfigParser().write(configfile)
-        return 'success'
+        try:
+            self.config.remove_section(address)
+        except ConfigParser.NoSectionError:
+            raise APIError(
+                13, 'Could not find this address in your keys.dat file.')
+        self.config.save()
+        queues.UISignalQueue.put(('rerenderMessagelistFromLabels', ''))
+        queues.UISignalQueue.put(('rerenderMessagelistToLabels', ''))
+        return "success"
 
-    def HandleDeleteAddress(self, params):
+    @command('deleteAddress')
+    def HandleDeleteAddress(self, address):
         """Handle a request to delete an address"""
-
-        if not params:
-            raise APIError(0, 'I need parameters.')
-        elif len(params) == 1:
-            address, = params
-        # pylint: disable=unused-variable
-        status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(address)
+        self._verifyAddress(address)
         address = addBMIfNotPresent(address)
-        if not BMConfigParser().has_section(address):
+        try:
+            self.config.remove_section(address)
+        except ConfigParser.NoSectionError:
             raise APIError(
                 13, 'Could not find this address in your keys.dat file.')
-        BMConfigParser().remove_section(address)
-        with open(state.appdata + 'keys.dat', 'wb') as configfile:
-            BMConfigParser().write(configfile)
+        self.config.save()
         queues.UISignalQueue.put(('writeNewAddressToTable', ('', '', '')))
         shared.reloadMyAddressHashes()
-        return 'success'
+        return "success"
 
-    def HandleGetAllInboxMessages(self, params):  # pylint: disable=unused-argument
+    @command('getAllInboxMessages')
+    def HandleGetAllInboxMessages(self):
         """Handle a request to get all inbox messages"""
 
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, received, message,"
-            " encodingtype, read FROM inbox where folder='inbox'"
+            " encodingtype, read FROM inbox WHERE folder='inbox'"
             " ORDER BY received"
         )
-        data = '{"inboxMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype, read = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received,
-                'read': read}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetAllInboxMessageIds(self, params):  # pylint: disable=unused-argument
+        return {"inboxMessages": [
+            self._dump_inbox_message(*data) for data in queryreturn
+        ]}
+
+    @command('getAllInboxMessageIds', 'getAllInboxMessageIDs')
+    def HandleGetAllInboxMessageIds(self):
         """Handle a request to get all inbox message IDs"""
 
         queryreturn = sqlQuery(
             "SELECT msgid FROM inbox where folder='inbox' ORDER BY received")
-        data = '{"inboxMessageIds":['
-        for row in queryreturn:
-            msgid = row[0]
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'msgid': hexlify(msgid)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetInboxMessageById(self, params):
+
+        return {"inboxMessageIds": [
+            {'msgid': hexlify(msgid)} for msgid, in queryreturn
+        ]}
+
+    @command('getInboxMessageById', 'getInboxMessageByID')
+    def HandleGetInboxMessageById(self, hid, readStatus=None):
         """Handle a request to get an inbox messsage by ID"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        elif len(params) == 1:
-            msgid = self._decode(params[0], "hex")
-        elif len(params) >= 2:
-            msgid = self._decode(params[0], "hex")
-            readStatus = params[1]
+        msgid = self._decode(hid, "hex")
+        if readStatus is not None:
             if not isinstance(readStatus, bool):
                 raise APIError(
                     23, 'Bool expected in readStatus, saw %s instead.' %
@@ -725,34 +724,26 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             queryreturn = sqlQuery(
                 "SELECT read FROM inbox WHERE msgid=?", msgid)
             # UPDATE is slow, only update if status is different
-            if queryreturn != [] and (queryreturn[0][0] == 1) != readStatus:
-                sqlExecute(
-                    "UPDATE inbox set read = ? WHERE msgid=?",
-                    readStatus, msgid)
-                queues.UISignalQueue.put(('changedInboxUnread', None))
+            try:
+                if (queryreturn[0][0] == 1) != readStatus:
+                    sqlExecute(
+                        "UPDATE inbox set read = ? WHERE msgid=?",
+                        readStatus, msgid)
+                    queues.UISignalQueue.put(('changedInboxUnread', None))
+            except IndexError:
+                pass
         queryreturn = sqlQuery(
-            "SELECT msgid, toaddress, fromaddress, subject, received, message,"
+            "SELECT toaddress, fromaddress, subject, received, message,"
             " encodingtype, read FROM inbox WHERE msgid=?", msgid
         )
-        data = '{"inboxMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype, read = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received,
-                'read': read}, indent=4, separators=(',', ': '))
-            data += ']}'
-            return data
-
-    def HandleGetAllSentMessages(self, params):  # pylint: disable=unused-argument
+        try:
+            return {"inboxMessage": [
+                self._dump_inbox_message(*queryreturn[0])]}
+        except IndexError:
+            pass  # FIXME inconsistent
+
+    @command('getAllSentMessages')
+    def HandleGetAllSentMessages(self):
         """Handle a request to get all sent messages"""
 
         queryreturn = sqlQuery(
@@ -760,217 +751,116 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE folder='sent' ORDER BY lastactiontime"
         )
-        data = '{"sentMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetAllSentMessageIds(self, params):  # pylint: disable=unused-argument
+        return {"sentMessages": [
+            self._dump_sent_message(*data) for data in queryreturn
+        ]}
+
+    @command('getAllSentMessageIds', 'getAllSentMessageIDs')
+    def HandleGetAllSentMessageIds(self):
         """Handle a request to get all sent message IDs"""
 
         queryreturn = sqlQuery(
-            "SELECT msgid FROM sent where folder='sent'"
+            "SELECT msgid FROM sent WHERE folder='sent'"
             " ORDER BY lastactiontime"
         )
-        data = '{"sentMessageIds":['
-        for row in queryreturn:
-            msgid = row[0]
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'msgid': hexlify(msgid)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleInboxMessagesByReceiver(self, params):
+        return {"sentMessageIds": [
+            {'msgid': hexlify(msgid)} for msgid, in queryreturn
+        ]}
+
+    # after some time getInboxMessagesByAddress should be removed
+    @command('getInboxMessagesByReceiver', 'legacy:getInboxMessagesByAddress')
+    def HandleInboxMessagesByReceiver(self, toAddress):
         """Handle a request to get inbox messages by receiver"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        toAddress = params[0]
         queryreturn = sqlQuery(
-            "SELECT msgid, toaddress, fromaddress, subject, received, message,"
-            " encodingtype FROM inbox WHERE folder='inbox' AND toAddress=?",
-            toAddress)
-        data = '{"inboxMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetSentMessageById(self, params):
+            "SELECT msgid, toaddress, fromaddress, subject, received,"
+            " message, encodingtype, read FROM inbox WHERE folder='inbox'"
+            " AND toAddress=?", toAddress)
+        return {"inboxMessages": [
+            self._dump_inbox_message(*data) for data in queryreturn
+        ]}
+
+    @command('getSentMessageById', 'getSentMessageByID')
+    def HandleGetSentMessageById(self, hid):
         """Handle a request to get a sent message by ID"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(hid, "hex")
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent WHERE msgid=?",
             msgid
         )
-        data = '{"sentMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-            data += ']}'
-            return data
-
-    def HandleGetSentMessagesByAddress(self, params):
+        try:
+            return {"sentMessage": [
+                self._dump_sent_message(*queryreturn[0])
+            ]}
+        except IndexError:
+            pass  # FIXME inconsistent
+
+    @command('getSentMessagesByAddress', 'getSentMessagesBySender')
+    def HandleGetSentMessagesByAddress(self, fromAddress):
         """Handle a request to get sent messages by address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        fromAddress = params[0]
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE folder='sent' AND fromAddress=? ORDER BY lastactiontime",
             fromAddress
         )
-        data = '{"sentMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row  # pylint: disable=unused-variable
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetSentMessagesByAckData(self, params):
+        return {"sentMessages": [
+            self._dump_sent_message(*data) for data in queryreturn
+        ]}
+
+    @command('getSentMessageByAckData')
+    def HandleGetSentMessagesByAckData(self, ackData):
         """Handle a request to get sent messages by ack data"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        ackData = self._decode(params[0], "hex")
+        ackData = self._decode(ackData, "hex")
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE ackdata=?", ackData
         )
-        data = '{"sentMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleTrashMessage(self, params):
-        """Handle a request to trash a message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
 
+        try:
+            return {"sentMessage": [
+                self._dump_sent_message(*queryreturn[0])
+            ]}
+        except IndexError:
+            pass  # FIXME inconsistent
+
+    @command('trashMessage')
+    def HandleTrashMessage(self, msgid):
+        """Handle a request to trash a message by ID"""
+        msgid = self._decode(msgid, "hex")
         # Trash if in inbox table
         helper_inbox.trash(msgid)
         # Trash if in sent table
-        sqlExecute('''UPDATE sent SET folder='trash' WHERE msgid=?''', msgid)
+        sqlExecute("UPDATE sent SET folder='trash' WHERE msgid=?", msgid)
         return 'Trashed message (assuming message existed).'
 
-    def HandleTrashInboxMessage(self, params):
+    @command('trashInboxMessage')
+    def HandleTrashInboxMessage(self, msgid):
         """Handle a request to trash an inbox message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(msgid, "hex")
         helper_inbox.trash(msgid)
         return 'Trashed inbox message (assuming message existed).'
 
-    def HandleTrashSentMessage(self, params):
+    @command('trashSentMessage')
+    def HandleTrashSentMessage(self, msgid):
         """Handle a request to trash a sent message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(msgid, "hex")
         sqlExecute('''UPDATE sent SET folder='trash' WHERE msgid=?''', msgid)
         return 'Trashed sent message (assuming message existed).'
 
-    def HandleSendMessage(self, params):
+    @command('sendMessage')
+    def HandleSendMessage(
+        self, toAddress, fromAddress, subject, message,
+        encodingType=2, TTL=4 * 24 * 60 * 60
+    ):
         """Handle a request to send a message"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 4:
-            toAddress, fromAddress, subject, message = params
-            encodingType = 2
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 5:
-            toAddress, fromAddress, subject, message, encodingType = params
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 6:
-            toAddress, fromAddress, subject, message, encodingType, TTL = \
-                params
-
-        if encodingType not in [2, 3]:
+        if encodingType not in (2, 3):
             raise APIError(6, 'The encoding type must be 2 or 3.')
         subject = self._decode(subject, "base64")
         message = self._decode(message, "base64")
@@ -982,12 +872,10 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             TTL = 28 * 24 * 60 * 60
         toAddress = addBMIfNotPresent(toAddress)
         fromAddress = addBMIfNotPresent(fromAddress)
-        # pylint: disable=unused-variable
-        status, addressVersionNumber, streamNumber, toRipe = \
-            self._verifyAddress(toAddress)
+        _, _, streamNumber, toRipe = self._verifyAddress(toAddress)
         self._verifyAddress(fromAddress)
         try:
-            fromAddressEnabled = BMConfigParser().getboolean(
+            fromAddressEnabled = self.config.getboolean(
                 fromAddress, 'enabled')
         except BaseException:
             raise APIError(
@@ -995,7 +883,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         if not fromAddressEnabled:
             raise APIError(14, 'Your fromAddress is disabled. Cannot send.')
 
-        stealthLevel = BMConfigParser().safeGetInt(
+        stealthLevel = self.config.safeGetInt(
             'bitmessagesettings', 'ackstealthlevel')
         ackdata = genAckPayload(streamNumber, stealthLevel)
 
@@ -1019,34 +907,24 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         toLabel = ''
         queryreturn = sqlQuery(
             "SELECT label FROM addressbook WHERE address=?", toAddress)
-        if queryreturn != []:
-            for row in queryreturn:
-                toLabel, = row
+        try:
+            toLabel, = queryreturn[0][0]
+        except IndexError:
+            pass
+
         queues.UISignalQueue.put(('displayNewSentMessage', (
             toAddress, toLabel, fromAddress, subject, message, ackdata)))
-
         queues.workerQueue.put(('sendmessage', toAddress))
 
         return hexlify(ackdata)
 
-    def HandleSendBroadcast(self, params):
+    @command('sendBroadcast')
+    def HandleSendBroadcast(
+        self, fromAddress, subject, message, encodingType=2,
+            TTL=4 * 24 * 60 * 60):
         """Handle a request to send a broadcast message"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        if len(params) == 3:
-            fromAddress, subject, message = params
-            encodingType = 2
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 4:
-            fromAddress, subject, message, encodingType = params
-            TTL = 4 * 24 * 60 * 60
-        elif len(params) == 5:
-            fromAddress, subject, message, encodingType, TTL = params
-
-        if encodingType not in [2, 3]:
+        if encodingType not in (2, 3):
             raise APIError(6, 'The encoding type must be 2 or 3.')
 
         subject = self._decode(subject, "base64")
@@ -1060,13 +938,13 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         fromAddress = addBMIfNotPresent(fromAddress)
         self._verifyAddress(fromAddress)
         try:
-            BMConfigParser().getboolean(fromAddress, 'enabled')
+            self.config.getboolean(fromAddress, 'enabled')
         except BaseException:
             raise APIError(
-                13, 'could not find your fromAddress in the keys.dat file.')
+                13, 'Could not find your fromAddress in the keys.dat file.')
         streamNumber = decodeAddress(fromAddress)[2]
         ackdata = genAckPayload(streamNumber, 0)
-        toAddress = '[Broadcast subscribers]'
+        toAddress = str_broadcast_subscribers
         ripe = ''
 
         t = ('',
@@ -1086,55 +964,45 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
              TTL)
         helper_sent.insert(t)
 
-        toLabel = '[Broadcast subscribers]'
+        toLabel = str_broadcast_subscribers
         queues.UISignalQueue.put(('displayNewSentMessage', (
             toAddress, toLabel, fromAddress, subject, message, ackdata)))
         queues.workerQueue.put(('sendbroadcast', ''))
 
         return hexlify(ackdata)
 
-    def HandleGetStatus(self, params):
+    @command('getStatus')
+    def HandleGetStatus(self, ackdata):
         """Handle a request to get the status of a sent message"""
 
-        if len(params) != 1:
-            raise APIError(0, 'I need one parameter!')
-        ackdata, = params
         if len(ackdata) < 76:
             # The length of ackData should be at least 38 bytes (76 hex digits)
             raise APIError(15, 'Invalid ackData object size.')
         ackdata = self._decode(ackdata, "hex")
         queryreturn = sqlQuery(
             "SELECT status FROM sent where ackdata=?", ackdata)
-        if queryreturn == []:
+        try:
+            return queryreturn[0][0]
+        except IndexError:
             return 'notfound'
-        for row in queryreturn:
-            status, = row
-            return status
 
-    def HandleAddSubscription(self, params):
+    @command('addSubscription')
+    def HandleAddSubscription(self, address, label=''):
         """Handle a request to add a subscription"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        if len(params) == 1:
-            address, = params
-            label = ''
-        if len(params) == 2:
-            address, label = params
+        if label:
             label = self._decode(label, "base64")
             try:
                 unicode(label, 'utf-8')
-            except BaseException:
+            except UnicodeDecodeError:
                 raise APIError(17, 'Label is not valid UTF-8 data.')
-        if len(params) > 2:
-            raise APIError(0, 'I need either 1 or 2 parameters!')
-        address = addBMIfNotPresent(address)
         self._verifyAddress(address)
+        address = addBMIfNotPresent(address)
         # First we must check to see if the address is already in the
         # subscriptions list.
         queryreturn = sqlQuery(
             "SELECT * FROM subscriptions WHERE address=?", address)
-        if queryreturn != []:
+        if queryreturn:
             raise APIError(16, 'You are already subscribed to that address.')
         sqlExecute(
             "INSERT INTO subscriptions VALUES (?,?,?)", label, address, True)
@@ -1143,37 +1011,37 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderSubscriptions', ''))
         return 'Added subscription.'
 
-    def HandleDeleteSubscription(self, params):
+    @command('deleteSubscription')
+    def HandleDeleteSubscription(self, address):
         """Handle a request to delete a subscription"""
 
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        address, = params
         address = addBMIfNotPresent(address)
-        sqlExecute('''DELETE FROM subscriptions WHERE address=?''', address)
+        sqlExecute("DELETE FROM subscriptions WHERE address=?", address)
         shared.reloadBroadcastSendersForWhichImWatching()
         queues.UISignalQueue.put(('rerenderMessagelistFromLabels', ''))
         queues.UISignalQueue.put(('rerenderSubscriptions', ''))
         return 'Deleted subscription if it existed.'
 
-    def ListSubscriptions(self, params):  # pylint: disable=unused-argument
+    @command('listSubscriptions')
+    def ListSubscriptions(self):
         """Handle a request to list susbcriptions"""
 
-        # pylint: disable=unused-variable
         queryreturn = sqlQuery(
             "SELECT label, address, enabled FROM subscriptions")
-        data = {'subscriptions': []}
-        for row in queryreturn:
-            label, address, enabled = row
+        data = []
+        for label, address, enabled in queryreturn:
             label = shared.fixPotentiallyInvalidUTF8Data(label)
-            data['subscriptions'].append({
+            data.append({
                 'label': base64.b64encode(label),
                 'address': address,
                 'enabled': enabled == 1
             })
-        return json.dumps(data, indent=4, separators=(',', ': '))
+        return {'subscriptions': data}
 
-    def HandleDisseminatePreEncryptedMsg(self, params):
+    @command('disseminatePreEncryptedMsg')
+    def HandleDisseminatePreEncryptedMsg(
+        self, encryptedPayload, requiredAverageProofOfWorkNonceTrialsPerByte,
+            requiredPayloadLengthExtraBytes):
         """Handle a request to disseminate an encrypted message"""
 
         # The device issuing this command to PyBitmessage supplies a msg
@@ -1181,38 +1049,28 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # to be done. PyBitmessage accepts this msg object and sends it out
         # to the rest of the Bitmessage network as if it had generated
         # the message itself. Please do not yet add this to the api doc.
-        if len(params) != 3:
-            raise APIError(0, 'I need 3 parameter!')
-        encryptedPayload, requiredAverageProofOfWorkNonceTrialsPerByte, \
-            requiredPayloadLengthExtraBytes = params
         encryptedPayload = self._decode(encryptedPayload, "hex")
         # Let us do the POW and attach it to the front
-        target = 2**64 / (
-            (
-                len(encryptedPayload) + requiredPayloadLengthExtraBytes + 8
-            ) * requiredAverageProofOfWorkNonceTrialsPerByte
+        target = 2**64 / ((
+            len(encryptedPayload) + requiredPayloadLengthExtraBytes + 8) *
+            requiredAverageProofOfWorkNonceTrialsPerByte)
+        logger.warning(
+            '(For msg message via API) Doing proof of work. Total  required'
+            ' difficulty: %s\nRequired small message difficulty: %s',
+            float(requiredAverageProofOfWorkNonceTrialsPerByte) /
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+            float(requiredPayloadLengthExtraBytes) /
+            defaults.networkDefaultPayloadLengthExtraBytes,
         )
-        with shared.printLock:
-            print(
-                '(For msg message via API) Doing proof of work. Total required difficulty:',
-                float(
-                    requiredAverageProofOfWorkNonceTrialsPerByte
-                ) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
-                'Required small message difficulty:',
-                float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes,
-            )
         powStartTime = time.time()
         initialHash = hashlib.sha512(encryptedPayload).digest()
         trialValue, nonce = proofofwork.run(target, initialHash)
-        with shared.printLock:
-            print '(For msg message via API) Found proof of work', trialValue, 'Nonce:', nonce
-            try:
-                print(
-                    'POW took', int(time.time() - powStartTime), 'seconds.',
-                    nonce / (time.time() - powStartTime), 'nonce trials per second.',
-                )
-            except BaseException:
-                pass
+        logger.warning(
+            '(For msg message via API) Found proof of work %s\nNonce: %s\n'
+            'POW took %s seconds. %s nonce trials per second.',
+            trialValue, nonce, int(time.time() - powStartTime),
+            nonce / (time.time() - powStartTime)
+        )
         encryptedPayload = pack('>Q', nonce) + encryptedPayload
         toStreamNumber = decodeVarint(encryptedPayload[16:26])[0]
         inventoryHash = calculateInventoryHash(encryptedPayload)
@@ -1222,21 +1080,21 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             objectType, toStreamNumber, encryptedPayload,
             int(time.time()) + TTL, ''
         )
-        with shared.printLock:
-            print 'Broadcasting inv for msg(API disseminatePreEncryptedMsg command):', hexlify(inventoryHash)
+        logger.warning(
+            'Broadcasting inv for msg(API disseminatePreEncryptedMsg'
+            ' command): %s', hexlify(inventoryHash))
         queues.invQueue.put((toStreamNumber, inventoryHash))
 
-    def HandleTrashSentMessageByAckDAta(self, params):
+    @command('trashSentMessageByAckData')
+    def HandleTrashSentMessageByAckDAta(self, ackdata):
         """Handle a request to trash a sent message by ackdata"""
-
         # This API method should only be used when msgid is not available
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        ackdata = self._decode(params[0], "hex")
+        ackdata = self._decode(ackdata, "hex")
         sqlExecute("UPDATE sent SET folder='trash' WHERE ackdata=?", ackdata)
         return 'Trashed sent message (assuming message existed).'
 
-    def HandleDissimatePubKey(self, params):  # pylint: disable=unused-argument
+    @command('disseminatePubkey')
+    def HandleDissimatePubKey(self, payload):
         """Handle a request to disseminate a public key"""
 
         # The device issuing this command to PyBitmessage supplies a pubkey
@@ -1244,19 +1102,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # PyBitmessage accepts this pubkey object and sends it out to the rest
         # of the Bitmessage network as if it had generated the pubkey object
         # itself. Please do not yet add this to the api doc.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        payload, = params
         payload = self._decode(payload, "hex")
 
         # Let us do the POW
         target = 2 ** 64 / ((
             len(payload) + defaults.networkDefaultPayloadLengthExtraBytes + 8
         ) * defaults.networkDefaultProofOfWorkNonceTrialsPerByte)
-        print '(For pubkey message via API) Doing proof of work...'
+        logger.warning('(For pubkey message via API) Doing proof of work...')
         initialHash = hashlib.sha512(payload).digest()
         trialValue, nonce = proofofwork.run(target, initialHash)
-        print '(For pubkey message via API) Found proof of work', trialValue, 'Nonce:', nonce
+        logger.warning(
+            '(For pubkey message via API) Found proof of work %s Nonce: %s',
+            trialValue, nonce
+        )
         payload = pack('>Q', nonce) + payload
 
         pubkeyReadPosition = 8  # bypass the nonce
@@ -1266,8 +1124,8 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         else:
             pubkeyReadPosition += 4
         # pylint: disable=unused-variable
-        addressVersion, addressVersionLength = decodeVarint(
-            payload[pubkeyReadPosition:pubkeyReadPosition + 10])
+        addressVersionLength = decodeVarint(
+            payload[pubkeyReadPosition:pubkeyReadPosition + 10])[1]
         pubkeyReadPosition += addressVersionLength
         pubkeyStreamNumber = decodeVarint(
             payload[pubkeyReadPosition:pubkeyReadPosition + 10])[0]
@@ -1277,19 +1135,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         Inventory()[inventoryHash] = (
             objectType, pubkeyStreamNumber, payload, int(time.time()) + TTL, ''
         )
-        with shared.printLock:
-            print 'broadcasting inv within API command disseminatePubkey with hash:', hexlify(inventoryHash)
+        logger.warning(
+            'broadcasting inv within API command disseminatePubkey with'
+            ' hash: %s', hexlify(inventoryHash))
         queues.invQueue.put((pubkeyStreamNumber, inventoryHash))
 
-    def HandleGetMessageDataByDestinationHash(self, params):
+    @command(
+        'getMessageDataByDestinationHash', 'getMessageDataByDestinationTag')
+    def HandleGetMessageDataByDestinationHash(self, requestedHash):
         """Handle a request to get message data by destination hash"""
 
         # Method will eventually be used by a particular Android app to
         # select relevant messages. Do not yet add this to the api
         # doc.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        requestedHash, = params
         if len(requestedHash) != 32:
             raise APIError(
                 19, 'The length of hash should be 32 bytes (encoded in hex'
@@ -1303,8 +1161,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             "SELECT hash, payload FROM inventory WHERE tag = ''"
             " and objecttype = 2")
         with SqlBulkExecute() as sql:
-            for row in queryreturn:
-                hash01, payload = row
+            for hash01, payload in queryreturn:
                 readPosition = 16  # Nonce length + time length
                 # Stream Number length
                 readPosition += decodeVarint(
@@ -1314,17 +1171,12 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
 
         queryreturn = sqlQuery(
             "SELECT payload FROM inventory WHERE tag = ?", requestedHash)
-        data = '{"receivedMessageDatas":['
-        for row in queryreturn:
-            payload, = row
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'data': hexlify(payload)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleClientStatus(self, params):  # pylint: disable=unused-argument
+        return {"receivedMessageDatas": [
+            {'data': hexlify(payload)} for payload, in queryreturn
+        ]}
+
+    @command('clientStatus')
+    def HandleClientStatus(self):
         """Handle a request to get the status of the client"""
 
         connections_num = len(network.stats.connectedHostsList())
@@ -1334,7 +1186,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             networkStatus = 'connectedAndReceivingIncomingConnections'
         else:
             networkStatus = 'connectedButHaveNotReceivedIncomingConnections'
-        return json.dumps({
+        return {
             'networkConnections': connections_num,
             'numberOfMessagesProcessed': shared.numberOfMessagesProcessed,
             'numberOfBroadcastsProcessed': shared.numberOfBroadcastsProcessed,
@@ -1342,140 +1194,89 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             'networkStatus': networkStatus,
             'softwareName': 'PyBitmessage',
             'softwareVersion': softwareVersion
-        }, indent=4, separators=(',', ': '))
-
-    def HandleDecodeAddress(self, params):
-        """Handle a request to decode an address"""
-
-        # Return a meaningful decoding of an address.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        address, = params
-        status, addressVersion, streamNumber, ripe = decodeAddress(address)
-        return json.dumps({
-            'status': status,
-            'addressVersion': addressVersion,
-            'streamNumber': streamNumber,
-            'ripe': base64.b64encode(ripe)
-        }, indent=4, separators=(',', ': '))
+        }
 
-    def HandleHelloWorld(self, params):
+    @command('helloWorld')
+    def HandleHelloWorld(self, a, b):
         """Test two string params"""
-
-        a, b = params
         return a + '-' + b
 
-    def HandleAdd(self, params):
+    @command('add')
+    def HandleAdd(self, a, b):
         """Test two numeric params"""
-
-        a, b = params
         return a + b
 
-    def HandleStatusBar(self, params):
+    @command('statusBar')
+    def HandleStatusBar(self, message):
         """Handle a request to update the status bar"""
-
-        message, = params
         queues.UISignalQueue.put(('updateStatusBar', message))
 
-    def HandleDeleteAndVacuum(self, params):
+    @command('deleteAndVacuum')
+    def HandleDeleteAndVacuum(self):
         """Handle a request to run the deleteandvacuum stored procedure"""
+        sqlStoredProcedure('deleteandvacuume')
+        return 'done'
 
-        if not params:
-            sqlStoredProcedure('deleteandvacuume')
-            return 'done'
-        return None
-
-    def HandleShutdown(self, params):
-        """Handle a request to huutdown the client"""
-
-        if not params:
-            shutdown.doCleanShutdown()
-            return 'done'
-        return None
-
-    handlers = {}
-    handlers['helloWorld'] = HandleHelloWorld
-    handlers['add'] = HandleAdd
-    handlers['statusBar'] = HandleStatusBar
-    handlers['listAddresses'] = HandleListAddresses
-    handlers['listAddressBookEntries'] = HandleListAddressBookEntries
-    # the listAddressbook alias should be removed eventually.
-    handlers['listAddressbook'] = HandleListAddressBookEntries
-    handlers['addAddressBookEntry'] = HandleAddAddressBookEntry
-    # the addAddressbook alias should be deleted eventually.
-    handlers['addAddressbook'] = HandleAddAddressBookEntry
-    handlers['deleteAddressBookEntry'] = HandleDeleteAddressBookEntry
-    # The deleteAddressbook alias should be deleted eventually.
-    handlers['deleteAddressbook'] = HandleDeleteAddressBookEntry
-    handlers['createRandomAddress'] = HandleCreateRandomAddress
-    handlers['createDeterministicAddresses'] = \
-        HandleCreateDeterministicAddresses
-    handlers['getDeterministicAddress'] = HandleGetDeterministicAddress
-    handlers['createChan'] = HandleCreateChan
-    handlers['joinChan'] = HandleJoinChan
-    handlers['leaveChan'] = HandleLeaveChan
-    handlers['deleteAddress'] = HandleDeleteAddress
-    handlers['getAllInboxMessages'] = HandleGetAllInboxMessages
-    handlers['getAllInboxMessageIds'] = HandleGetAllInboxMessageIds
-    handlers['getAllInboxMessageIDs'] = HandleGetAllInboxMessageIds
-    handlers['getInboxMessageById'] = HandleGetInboxMessageById
-    handlers['getInboxMessageByID'] = HandleGetInboxMessageById
-    handlers['getAllSentMessages'] = HandleGetAllSentMessages
-    handlers['getAllSentMessageIds'] = HandleGetAllSentMessageIds
-    handlers['getAllSentMessageIDs'] = HandleGetAllSentMessageIds
-    handlers['getInboxMessagesByReceiver'] = HandleInboxMessagesByReceiver
-    # after some time getInboxMessagesByAddress should be removed
-    handlers['getInboxMessagesByAddress'] = HandleInboxMessagesByReceiver
-    handlers['getSentMessageById'] = HandleGetSentMessageById
-    handlers['getSentMessageByID'] = HandleGetSentMessageById
-    handlers['getSentMessagesByAddress'] = HandleGetSentMessagesByAddress
-    handlers['getSentMessagesBySender'] = HandleGetSentMessagesByAddress
-    handlers['getSentMessageByAckData'] = HandleGetSentMessagesByAckData
-    handlers['trashMessage'] = HandleTrashMessage
-    handlers['trashInboxMessage'] = HandleTrashInboxMessage
-    handlers['trashSentMessage'] = HandleTrashSentMessage
-    handlers['trashSentMessageByAckData'] = HandleTrashSentMessageByAckDAta
-    handlers['sendMessage'] = HandleSendMessage
-    handlers['sendBroadcast'] = HandleSendBroadcast
-    handlers['getStatus'] = HandleGetStatus
-    handlers['addSubscription'] = HandleAddSubscription
-    handlers['deleteSubscription'] = HandleDeleteSubscription
-    handlers['listSubscriptions'] = ListSubscriptions
-    handlers['disseminatePreEncryptedMsg'] = HandleDisseminatePreEncryptedMsg
-    handlers['disseminatePubkey'] = HandleDissimatePubKey
-    handlers['getMessageDataByDestinationHash'] = \
-        HandleGetMessageDataByDestinationHash
-    handlers['getMessageDataByDestinationTag'] = \
-        HandleGetMessageDataByDestinationHash
-    handlers['clientStatus'] = HandleClientStatus
-    handlers['decodeAddress'] = HandleDecodeAddress
-    handlers['deleteAndVacuum'] = HandleDeleteAndVacuum
-    handlers['shutdown'] = HandleShutdown
+    @command('shutdown')
+    def HandleShutdown(self):
+        """Handle a request to shutdown the node"""
+        # backward compatible trick because False == 0 is True
+        state.shutdown = False
+        return 'done'
 
     def _handle_request(self, method, params):
-        if method not in self.handlers:
+        try:
+            self._method = method
+            func = self._handlers[method]
+            return func(self, *params)
+        except KeyError:
             raise APIError(20, 'Invalid method: %s' % method)
-        result = self.handlers[method](self, params)
-        state.last_api_response = time.time()
-        return result
+        except TypeError as e:
+            msg = 'Unexpected API Failure - %s' % e
+            if 'argument' not in str(e):
+                raise APIError(0, msg)
+            argcount = len(params)
+            maxcount = func.func_code.co_argcount
+            if argcount > maxcount:
+                msg = (
+                    'Command %s takes at most %s parameters (%s given)' %
+                    (method, maxcount, argcount))
+            else:
+                mincount = maxcount - len(func.func_defaults or [])
+                if argcount < mincount:
+                    msg = (
+                        'Command %s takes at least %s parameters (%s given)' %
+                        (method, mincount, argcount))
+            raise APIError(0, msg)
+        finally:
+            state.last_api_response = time.time()
 
     def _dispatch(self, method, params):
-        # pylint: disable=attribute-defined-outside-init
-        self.cookies = []
-
-        validuser = self.APIAuthenticateClient()
-        if not validuser:
-            time.sleep(2)
-            return "RPC Username or password incorrect or HTTP header lacks authentication at all."
+        _fault = None
 
         try:
             return self._handle_request(method, params)
         except APIError as e:
-            return str(e)
+            _fault = e
         except varintDecodeError as e:
             logger.error(e)
-            return "API Error 0026: Data contains a malformed varint. Some details: %s" % e
+            _fault = APIError(
+                26, 'Data contains a malformed varint. Some details: %s' %
+                e)
         except Exception as e:
             logger.exception(e)
+            _fault = APIError(21, 'Unexpected API Failure - %s' % e)
+
+        if _fault:
+            if self.config.safeGet(
+                    'bitmessagesettings', 'apivariant') == 'legacy':
+                return str(_fault)
+            else:
+                raise _fault  # pylint: disable=raising-bad-type
+
+    def _listMethods(self):
+        """List all API commands"""
+        return self._handlers.keys()
 
-            return "API Error 0021: Unexpected API Failure - %s" % e
+    def _methodHelp(self, method):
+        return self._handlers[method].__doc__
diff --git a/src/bitmessagemain.py b/src/bitmessagemain.py
index 4efd0154..bca82882 100755
--- a/src/bitmessagemain.py
+++ b/src/bitmessagemain.py
@@ -223,6 +223,8 @@ class Main:
                     'bitmessagesettings', 'apiusername', 'username')
                 config.set(
                     'bitmessagesettings', 'apipassword', 'password')
+                config.set(
+                    'bitmessagesettings', 'apivariant', 'legacy')
                 config.set(
                     'bitmessagesettings', 'apinotifypath',
                     os.path.join(app_dir, 'tests', 'apinotify_handler.py')
diff --git a/src/tests/test_api.py b/src/tests/test_api.py
index 2bb6d0ce..c94ec3b5 100644
--- a/src/tests/test_api.py
+++ b/src/tests/test_api.py
@@ -4,31 +4,48 @@ Tests using API.
 
 import base64
 import json
+import time
 import xmlrpclib  # nosec
-from time import sleep
 
-from test_process import TestProcessProto
+from test_process import TestProcessProto, TestProcessShutdown
 
 
-class TestAPI(TestProcessProto):
-    """A test case for API"""
+class TestAPIProto(TestProcessProto):
+    """Test case logic for testing API"""
     _process_cmd = ['pybitmessage', '-t']
-    _seed = base64.encodestring(
-        'TIGER, tiger, burning bright. In the forests of the night'
-    )
 
     @classmethod
     def setUpClass(cls):
         """Setup XMLRPC proxy for pybitmessage API"""
-        super(TestAPI, cls).setUpClass()
+        super(TestAPIProto, cls).setUpClass()
         cls.addresses = []
         cls.api = xmlrpclib.ServerProxy(
             "http://username:password@127.0.0.1:8442/")
-        for _ in range(0, 5):
+        for _ in range(5):
             if cls._get_readline('.api_started'):
-                print('API start detected!')
                 return
-            sleep(1)
+            time.sleep(1)
+
+
+class TestAPIShutdown(TestAPIProto, TestProcessShutdown):
+    """Separate test case for API command 'shutdown'"""
+    def test_shutdown(self):
+        """Shutdown the pybitmessage"""
+        self.assertEquals(self.api.shutdown(), 'done')
+        for _ in range(5):
+            if not self.process.is_running():
+                break
+            time.sleep(2)
+        else:
+            self.fail(
+                '%s has not stopped in 10 sec' % ' '.join(self._process_cmd))
+
+
+class TestAPI(TestAPIProto):
+    """Main API test case"""
+    _seed = base64.encodestring(
+        'TIGER, tiger, burning bright. In the forests of the night'
+    )
 
     def _add_random_address(self, label):
         return self.api.createRandomAddress(base64.encodestring(label))
@@ -36,11 +53,8 @@ class TestAPI(TestProcessProto):
     def test_user_password(self):
         """Trying to connect with wrong username/password"""
         api_wrong = xmlrpclib.ServerProxy("http://test:wrong@127.0.0.1:8442/")
-        self.assertEqual(
-            api_wrong.clientStatus(),
-            'RPC Username or password incorrect or HTTP header lacks'
-            ' authentication at all.'
-        )
+        with self.assertRaises(xmlrpclib.ProtocolError):
+            api_wrong.clientStatus()
 
     def test_connection(self):
         """API command 'helloWorld'"""
@@ -143,14 +157,28 @@ class TestAPI(TestProcessProto):
     def test_send_broadcast(self):
         """API command 'sendBroadcast': ensure it returns ackData"""
         addr = self._add_random_address('random_2')
-        ack = self.api.sendBroadcast(
-            addr, base64.encodestring('test_subject'),
-            base64.encodestring('test message')
-        )
+        msg = base64.encodestring('test message')
+        ackdata = self.api.sendBroadcast(
+            addr, base64.encodestring('test_subject'), msg)
         try:
-            int(ack, 16)
+            int(ackdata, 16)
+            status = self.api.getStatus(ackdata)
+            if status == 'notfound':
+                raise KeyError
+            self.assertIn(
+                status, ('broadcastqueued', 'broadcastsent', 'doingmsgpow'))
+            for m in json.loads(self.api.getAllSentMessages())['sentMessages']:
+                if m['ackData'] == ackdata:
+                    sent_msg = m['message']
+                    break
+            else:
+                raise KeyError
         except ValueError:
             self.fail('sendBroadcast returned error or ackData is not hex')
+        except KeyError:
+            self.fail('Could not find sent broadcast in sent messages')
+        else:
+            self.assertEqual(sent_msg, msg.strip())
         finally:
             self.assertEqual(self.api.deleteAddress(addr), 'success')
 
