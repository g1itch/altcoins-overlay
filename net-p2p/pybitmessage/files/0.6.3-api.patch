diff --git a/setup.py b/setup.py
index 422524bd..28b494d5 100644
--- a/setup.py
+++ b/setup.py
@@ -22,7 +22,8 @@ EXTRAS_REQUIRE = {
         'curses',  # src/depends.py
         'python2-pythondialog',  # src/depends.py
         'm2r',  # fab build_docs
-    ]
+    ],
+    'xml': ['defusedxml']
 }
 
 
diff --git a/src/api.py b/src/api.py
index 9d32a5bb..70560438 100644
--- a/src/api.py
+++ b/src/api.py
@@ -1,20 +1,18 @@
-# pylint: disable=too-many-locals,too-many-lines,no-self-use,too-many-public-methods,too-many-branches
-# pylint: disable=too-many-statements
+# pylint: disable=protected-access,attribute-defined-outside-init,no-member
 """
 src/api.py
 ==========
+"""
 
 # Copyright (c) 2012-2016 Jonathan Warren
 # Copyright (c) 2012-2018 The Bitmessage developers
 
-This is not what you run to run the Bitmessage API. Instead, enable the API
-( https://bitmessage.org/wiki/API ) and optionally enable daemon mode
-( https://bitmessage.org/wiki/Daemon ) then run bitmessagemain.py.
-"""
-
-from __future__ import absolute_import
+# This is not what you run to run the Bitmessage API. Instead, enable the API
+# ( https://bitmessage.org/wiki/API ) and optionally enable daemon mode
+# ( https://bitmessage.org/wiki/Daemon ) then run bitmessagemain.py.
 
 import base64
+import ConfigParser
 import errno
 import hashlib
 import json
@@ -23,12 +21,11 @@ import socket
 import subprocess
 import threading
 import time
+import xmlrpclib
 from binascii import hexlify, unhexlify
 from SimpleXMLRPCServer import SimpleXMLRPCRequestHandler, SimpleXMLRPCServer
 from struct import pack
 
-from version import softwareVersion
-
 import defaults
 import helper_inbox
 import helper_sent
@@ -39,37 +36,34 @@ import queues
 import shared
 import shutdown
 import state
-from addresses import addBMIfNotPresent, calculateInventoryHash, decodeAddress, decodeVarint, varintDecodeError
+from addresses import (
+    addBMIfNotPresent, calculateInventoryHash, decodeAddress, decodeVarint,
+    varintDecodeError
+)
 from bmconfigparser import BMConfigParser
 from debug import logger
 from helper_ackPayload import genAckPayload
 from helper_sql import SqlBulkExecute, sqlExecute, sqlQuery, sqlStoredProcedure
 from inventory import Inventory
+from version import softwareVersion
 
-str_chan = '[chan]'
+try:  # TODO: write tests for XML vulnerabilities
+    from defusedxml.xmlrpc import monkey_patch
+except ImportError:
+    logger.warning(
+        'defusedxml not available, only use API on a secure, closed network.')
+else:
+    monkey_patch()
 
 
-class APIError(Exception):
-    """APIError exception class"""
+str_chan = '[chan]'
+str_broadcast_subscribers = '[Broadcast subscribers]'
 
-    def __init__(self, error_number, error_message):
-        super(APIError, self).__init__()
-        self.error_number = error_number
-        self.error_message = error_message
 
+class APIError(xmlrpclib.Fault):
+    """APIError exception class"""
     def __str__(self):
-        return "API Error %04i: %s" % (self.error_number, self.error_message)
-
-
-class StoppableXMLRPCServer(SimpleXMLRPCServer):
-    """A SimpleXMLRPCServer that honours state.shutdown"""
-    allow_reuse_address = True
-
-    def serve_forever(self):
-        """Start the SimpleXMLRPCServer"""
-        # pylint: disable=arguments-differ
-        while state.shutdown == 0:
-            self.handle_request()
+        return "API Error %04i: %s" % (self.faultCode, self.faultString)
 
 
 # This thread, of which there is only one, runs the API.
@@ -98,15 +92,40 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
             getattr(errno, 'WSAEADDRINUSE')
         except AttributeError:
             errno.WSAEADDRINUSE = errno.EADDRINUSE
+
+        RPCServerBase = SimpleXMLRPCServer
+        ct = 'text/xml'
+        if BMConfigParser().safeGet(
+                'bitmessagesettings', 'apivariant') == 'json':
+            try:
+                from jsonrpclib.SimpleJSONRPCServer import (
+                    SimpleJSONRPCServer as RPCServerBase)
+            except ImportError:
+                logger.warning(
+                    'jsonrpclib not available, failing back to XML-RPC')
+            else:
+                ct = 'application/json-rpc'
+
+        # Nested class. FIXME not found a better solution.
+        class StoppableRPCServer(RPCServerBase):
+            """A SimpleXMLRPCServer that honours state.shutdown"""
+            allow_reuse_address = True
+            content_type = ct
+
+            def serve_forever(self, poll_interval=None):
+                """Start the RPCServer"""
+                while state.shutdown == 0:
+                    self.handle_request()
+
         for attempt in range(50):
             try:
                 if attempt > 0:
                     port = random.randint(32767, 65535)
-                se = StoppableXMLRPCServer(
+                se = StoppableRPCServer(
                     (BMConfigParser().get(
                         'bitmessagesettings', 'apiinterface'),
                      port),
-                    MySimpleXMLRPCRequestHandler, True, True)
+                    BMXMLRPCRequestHandler, True, encoding='UTF-8')
             except socket.error as e:
                 if e.errno in (errno.EADDRINUSE, errno.WSAEADDRINUSE):
                     continue
@@ -116,6 +135,8 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
                         "bitmessagesettings", "apiport", str(port))
                     BMConfigParser().save()
                 break
+
+        se.register_instance(BMRPCDispatcher())
         se.register_introspection_functions()
 
         apiNotifyPath = BMConfigParser().safeGet(
@@ -135,13 +156,58 @@ class singleAPI(threading.Thread, helper_threading.StoppableThread):
         se.serve_forever()
 
 
-class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
+class CommandHandler(type):
     """
-    This is one of several classes that constitute the API
-
-    This class was written by Vaibhav Bhatia.  Modified by Jonathan Warren (Atheros).
-    http://code.activestate.com/recipes/501148-xmlrpc-serverclient-which-does-cookie-handling-and/
+    The metaclass for singleAPI which fills _handlers dict by methods
+    decorated with @command
     """
+    def __new__(mcs, name, bases, namespace):
+        result = super(CommandHandler, mcs).__new__(
+            mcs, name, bases, namespace)
+        result.config = BMConfigParser()
+        result._handlers = {}
+        apivariant = result.config.safeGet('bitmessagesettings', 'apivariant')
+        for func in namespace.values():
+            try:
+                for alias in getattr(func, '_cmd'):
+                    try:
+                        prefix, alias = alias.split(':')
+                        if apivariant != prefix:
+                            continue
+                    except ValueError:
+                        pass
+                    result._handlers[alias] = func
+            except AttributeError:
+                pass
+        return result
+
+
+class command(object):
+    """Decorator for API command method"""
+    def __init__(self, *aliases):
+        self.aliases = aliases
+
+    def __call__(self, func):
+        if BMConfigParser().safeGet(
+                'bitmessagesettings', 'apivariant') == 'legacy':
+            def wrapper(*args):
+                result = func(*args)
+                return result if isinstance(result, (int, str)) \
+                    else json.dumps(result, indent=4)
+            wrapper.__doc__ = func.__doc__
+        else:
+            wrapper = func
+        wrapper._cmd = self.aliases
+        return wrapper
+
+
+# This is one of several classes that constitute the API
+# This class was written by Vaibhav Bhatia.
+# Modified by Jonathan Warren (Atheros).
+# Further modified by the Bitmessage developers
+# http://code.activestate.com/recipes/501148
+class BMXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
+    """The main API handler"""
 
     def do_POST(self):
         """
@@ -173,22 +239,34 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 size_remaining -= len(L[-1])
             data = ''.join(L)
 
-            # In previous versions of SimpleXMLRPCServer, _dispatch
-            # could be overridden in this class, instead of in
-            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
-            # check to see if a subclass implements _dispatch and dispatch
-            # using that method if present.
-            response = self.server._marshaled_dispatch(  # pylint: disable=protected-access
-                data, getattr(self, '_dispatch', None)
-            )
-        except BaseException:  # This should only happen if the module is buggy
+            self.cookies = []
+
+            validuser = self.APIAuthenticateClient()
+            if not validuser:
+                time.sleep(2)
+                self.send_response(401)
+                self.end_headers()
+                return
+                # "RPC Username or password incorrect or HTTP header"
+                # " lacks authentication at all."
+            else:
+                # In previous versions of SimpleXMLRPCServer, _dispatch
+                # could be overridden in this class, instead of in
+                # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
+                # check to see if a subclass implements _dispatch and dispatch
+                # using that method if present.
+                # pylint: disable=protected-access
+                response = self.server._marshaled_dispatch(
+                    data, getattr(self, '_dispatch', None)
+                )
+        except Exception:  # This should only happen if the module is buggy
             # internal error, report as HTTP server error
             self.send_response(500)
             self.end_headers()
         else:
             # got a valid XML RPC response
             self.send_response(200)
-            self.send_header("Content-type", "text/xml")
+            self.send_header("Content-type", self.server.content_type)
             self.send_header("Content-length", str(len(response)))
 
             # HACK :start -> sends cookies here
@@ -205,15 +283,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             self.connection.shutdown(1)
 
     def APIAuthenticateClient(self):
-        """Predicate to check for valid API credentials in the request header"""
+        """
+        Predicate to check for valid API credentials in the request header
+        """
 
         if 'Authorization' in self.headers:
             # handle Basic authentication
-            _, encstr = self.headers.get('Authorization').split()
+            encstr = self.headers.get('Authorization').split()[1]
             emailid, password = encstr.decode('base64').split(':')
             return (
-                emailid == BMConfigParser().get('bitmessagesettings', 'apiusername') and
-                password == BMConfigParser().get('bitmessagesettings', 'apipassword')
+                emailid == BMConfigParser().get(
+                    'bitmessagesettings', 'apiusername') and
+                password == BMConfigParser().get(
+                    'bitmessagesettings', 'apipassword')
             )
         else:
             logger.warning(
@@ -223,6 +305,11 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
 
         return False
 
+
+class BMRPCDispatcher(object):
+    """This class is used to dispatch API commands"""
+    __metaclass__ = CommandHandler
+
     def _decode(self, text, decode_type):
         try:
             if decode_type == 'hex':
@@ -231,7 +318,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 return base64.b64decode(text)
         except Exception as e:
             raise APIError(
-                22, "Decode error - %s. Had trouble while decoding string: %r"
+                22, 'Decode error - %s. Had trouble while decoding string: %r'
                 % (e, text)
             )
         return None
@@ -240,20 +327,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         status, addressVersionNumber, streamNumber, ripe = \
             decodeAddress(address)
         if status != 'success':
-            logger.warning(
-                'API Error 0007: Could not decode address %s. Status: %s.',
-                address, status
-            )
-
             if status == 'checksumfailed':
                 raise APIError(8, 'Checksum failed for address: ' + address)
             if status == 'invalidcharacters':
                 raise APIError(9, 'Invalid characters in address: ' + address)
             if status == 'versiontoohigh':
-                raise APIError(10, 'Address version number too high (or zero) in address: ' + address)
+                raise APIError(
+                    10,
+                    'Address version number too high (or zero) in address: ' +
+                    address)
             if status == 'varintmalformed':
                 raise APIError(26, 'Malformed varint in address: ' + address)
-            raise APIError(7, 'Could not decode address: %s : %s' % (address, status))
+            raise APIError(
+                7, 'Could not decode address: %s : %s' % (address, status))
         if addressVersionNumber < 2 or addressVersionNumber > 4:
             raise APIError(
                 11, 'The address version number currently must be 2, 3 or 4.'
@@ -265,71 +351,93 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
                 ' Check the address.'
             )
 
-        return (status, addressVersionNumber, streamNumber, ripe)
+        return {
+            'status': status,
+            'addressVersion': addressVersionNumber,
+            'streamNumber': streamNumber,
+            'ripe': base64.b64encode(ripe)
+        } if self._method == 'decodeAddress' else (
+            status, addressVersionNumber, streamNumber, ripe)
+
+    def _dump_inbox_message(
+            self, msgid, toAddress, fromAddress, subject, received,
+            message, encodingtype, read):
+        subject = shared.fixPotentiallyInvalidUTF8Data(subject)
+        message = shared.fixPotentiallyInvalidUTF8Data(message)
+        return {
+            'msgid': hexlify(msgid),
+            'toAddress': toAddress,
+            'fromAddress': fromAddress,
+            'subject': base64.b64encode(subject),
+            'message': base64.b64encode(message),
+            'encodingType': encodingtype,
+            'receivedTime': received,
+            'read': read
+        }
+
+    def _dump_sent_message(
+            self, msgid, toAddress, fromAddress, subject, lastactiontime,
+            message, encodingtype, status, ackdata):
+        subject = shared.fixPotentiallyInvalidUTF8Data(subject)
+        message = shared.fixPotentiallyInvalidUTF8Data(message)
+        return {
+            'msgid': hexlify(msgid),
+            'toAddress': toAddress,
+            'fromAddress': fromAddress,
+            'subject': base64.b64encode(subject),
+            'message': base64.b64encode(message),
+            'encodingType': encodingtype,
+            'lastActionTime': lastactiontime,
+            'status': status,
+            'ackData': hexlify(ackdata)
+        }
 
     # Request Handlers
 
-    def HandleListAddresses(self, method):
-        """Handle a request to list addresses"""
-
-        data = '{"addresses":['
-        for addressInKeysFile in BMConfigParser().addresses():
-            status, addressVersionNumber, streamNumber, hash01 = decodeAddress(  # pylint: disable=unused-variable
-                addressInKeysFile)
-            if len(data) > 20:
-                data += ','
-            if BMConfigParser().has_option(addressInKeysFile, 'chan'):
-                chan = BMConfigParser().getboolean(addressInKeysFile, 'chan')
-            else:
-                chan = False
-            label = BMConfigParser().get(addressInKeysFile, 'label')
-            if method == 'listAddresses2':
+    @command('decodeAddress')
+    def HandleDecodeAddress(self, address):
+        return self._verifyAddress(address)
+
+    @command('listAddresses', 'listAddresses2')
+    def HandleListAddresses(self):
+        data = []
+        for address in self.config.addresses():
+            streamNumber = decodeAddress(address)[2]
+            label = self.config.get(address, 'label')
+            if self._method == 'listAddresses2':
                 label = base64.b64encode(label)
-            data += json.dumps({
+            data.append({
                 'label': label,
-                'address': addressInKeysFile,
+                'address': address,
                 'stream': streamNumber,
-                'enabled':
-                BMConfigParser().getboolean(addressInKeysFile, 'enabled'),
-                'chan': chan
-            }, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleListAddressBookEntries(self, params):
-        """Handle a request to list address book entries"""
-
-        if len(params) == 1:
-            label, = params
-            label = self._decode(label, "base64")
-            queryreturn = sqlQuery(
-                "SELECT label, address from addressbook WHERE label = ?",
-                label)
-        elif len(params) > 1:
-            raise APIError(0, "Too many paremeters, max 1")
-        else:
-            queryreturn = sqlQuery("SELECT label, address from addressbook")
-        data = '{"addresses":['
-        for row in queryreturn:
-            label, address = row
+                'enabled': self.config.safeGetBoolean(address, 'enabled'),
+                'chan': self.config.safeGetBoolean(address, 'chan')
+            })
+        return {'addresses': data}
+
+    # the listAddressbook alias should be removed eventually.
+    @command('listAddressBookEntries', 'legacy:listAddressbook')
+    def HandleListAddressBookEntries(self, label=None):
+        queryreturn = sqlQuery(
+            "SELECT label, address from addressbook WHERE label = ?",
+            label
+        ) if label else sqlQuery("SELECT label, address from addressbook")
+        data = []
+        for label, address in queryreturn:
             label = shared.fixPotentiallyInvalidUTF8Data(label)
-            if len(data) > 20:
-                data += ','
-            data += json.dumps({
+            data.append({
                 'label': base64.b64encode(label),
-                'address': address}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleAddAddressBookEntry(self, params):
-        """Handle a request to add an address book entry"""
+                'address': address
+            })
+        return {'addresses': data}
 
-        if len(params) != 2:
-            raise APIError(0, "I need label and address")
-        address, label = params
+    # the addAddressbook alias should be deleted eventually.
+    @command('addAddressBookEntry', 'legacy:addAddressbook')
+    def HandleAddAddressBookEntry(self, address, label):
         label = self._decode(label, "base64")
         address = addBMIfNotPresent(address)
         self._verifyAddress(address)
+        # TODO: add unique together constraint in the table
         queryreturn = sqlQuery(
             "SELECT address FROM addressbook WHERE address=?", address)
         if queryreturn != []:
@@ -342,12 +450,9 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderAddressBook', ''))
         return "Added address %s to address book" % address
 
-    def HandleDeleteAddressBookEntry(self, params):
-        """Handle a request to delete an address book entry"""
-
-        if len(params) != 1:
-            raise APIError(0, "I need an address")
-        address, = params
+    # the deleteAddressbook alias should be deleted eventually.
+    @command('deleteAddressBookEntry', 'legacy:deleteAddressbook')
+    def HandleDeleteAddressBookEntry(self, address):
         address = addBMIfNotPresent(address)
         self._verifyAddress(address)
         sqlExecute('DELETE FROM addressbook WHERE address=?', address)
@@ -356,46 +461,35 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderAddressBook', ''))
         return "Deleted address book entry for %s if it existed" % address
 
-    def HandleCreateRandomAddress(self, params):
+    @command('createRandomAddress')
+    def HandleCreateRandomAddress(
+        self, label, eighteenByteRipe=False, totalDifficulty=0,
+        smallMessageDifficulty=0
+    ):
         """Handle a request to create a random address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 1:
-            label, = params
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 2:
-            label, eighteenByteRipe = params
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 3:
-            label, eighteenByteRipe, totalDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-        elif len(params) == 4:
-            label, eighteenByteRipe, totalDifficulty, \
-                smallMessageDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = int(
-                defaults.networkDefaultPayloadLengthExtraBytes * smallMessageDifficulty)
-        else:
-            raise APIError(0, 'Too many parameters!')
+        nonceTrialsPerByte = self.config.get(
+            'bitmessagesettings', 'defaultnoncetrialsperbyte'
+        ) if not totalDifficulty else int(
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte *
+            totalDifficulty)
+        payloadLengthExtraBytes = self.config.get(
+            'bitmessagesettings', 'defaultpayloadlengthextrabytes'
+        ) if not smallMessageDifficulty else int(
+            defaults.networkDefaultPayloadLengthExtraBytes *
+            smallMessageDifficulty)
+
+        if not isinstance(eighteenByteRipe, bool):
+            raise APIError(
+                23, 'Bool expected in eighteenByteRipe, saw %s instead' %
+                type(eighteenByteRipe))
         label = self._decode(label, "base64")
         try:
             unicode(label, 'utf-8')
-        except BaseException:
+        except UnicodeDecodeError:
             raise APIError(17, 'Label is not valid UTF-8 data.')
         queues.apiAddressGeneratorReturnQueue.queue.clear()
+        # FIXME hard coded stream no
         streamNumberForAddress = 1
         queues.addressGeneratorQueue.put((
             'createRandomAddress', 4, streamNumberForAddress, label, 1, "",
@@ -403,77 +497,25 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         ))
         return queues.apiAddressGeneratorReturnQueue.get()
 
-    def HandleCreateDeterministicAddresses(self, params):
+    @command('createDeterministicAddresses')
+    def HandleCreateDeterministicAddresses(
+        self, passphrase, numberOfAddresses=1, addressVersionNumber=0,
+        streamNumber=0, eighteenByteRipe=False, totalDifficulty=0,
+        smallMessageDifficulty=0
+    ):
         """Handle a request to create a deterministic address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 1:
-            passphrase, = params
-            numberOfAddresses = 1
-            addressVersionNumber = 0
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 2:
-            passphrase, numberOfAddresses = params
-            addressVersionNumber = 0
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 3:
-            passphrase, numberOfAddresses, addressVersionNumber = params
-            streamNumber = 0
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 4:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber = params
-            eighteenByteRipe = False
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 5:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe = params
-            nonceTrialsPerByte = BMConfigParser().get(
-                'bitmessagesettings', 'defaultnoncetrialsperbyte')
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 6:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe, totalDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = BMConfigParser().get(
-                'bitmessagesettings', 'defaultpayloadlengthextrabytes')
-
-        elif len(params) == 7:
-            passphrase, numberOfAddresses, addressVersionNumber, \
-                streamNumber, eighteenByteRipe, totalDifficulty, \
-                smallMessageDifficulty = params
-            nonceTrialsPerByte = int(
-                defaults.networkDefaultProofOfWorkNonceTrialsPerByte * totalDifficulty)
-            payloadLengthExtraBytes = int(
-                defaults.networkDefaultPayloadLengthExtraBytes * smallMessageDifficulty)
-        else:
-            raise APIError(0, 'Too many parameters!')
+        nonceTrialsPerByte = self.config.get(
+            'bitmessagesettings', 'defaultnoncetrialsperbyte'
+        ) if not totalDifficulty else int(
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte *
+            totalDifficulty)
+        payloadLengthExtraBytes = self.config.get(
+            'bitmessagesettings', 'defaultpayloadlengthextrabytes'
+        ) if not smallMessageDifficulty else int(
+            defaults.networkDefaultPayloadLengthExtraBytes *
+            smallMessageDifficulty)
+
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         if not isinstance(eighteenByteRipe, bool):
@@ -484,13 +526,13 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # 0 means "just use the proper addressVersionNumber"
         if addressVersionNumber == 0:
             addressVersionNumber = 4
-        if addressVersionNumber != 3 and addressVersionNumber != 4:
+        if addressVersionNumber not in (3, 4):
             raise APIError(
                 2, 'The address version number currently must be 3, 4, or 0'
                 ' (which means auto-select). %i isn\'t supported.' %
                 addressVersionNumber)
         if streamNumber == 0:  # 0 means "just use the most available stream"
-            streamNumber = 1
+            streamNumber = 1  # FIXME hard coded stream no
         if streamNumber != 1:
             raise APIError(
                 3, 'The stream number must be 1 (or 0 which means'
@@ -515,27 +557,20 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             'unused API address', numberOfAddresses, passphrase,
             eighteenByteRipe, nonceTrialsPerByte, payloadLengthExtraBytes
         ))
-        data = '{"addresses":['
-        queueReturn = queues.apiAddressGeneratorReturnQueue.get()
-        for item in queueReturn:
-            if len(data) > 20:
-                data += ','
-            data += "\"" + item + "\""
-        data += ']}'
-        return data
-
-    def HandleGetDeterministicAddress(self, params):
+
+        return {'addresses': queues.apiAddressGeneratorReturnQueue.get()}
+
+    @command('getDeterministicAddress')
+    def HandleGetDeterministicAddress(
+            self, passphrase, addressVersionNumber, streamNumber):
         """Handle a request to get a deterministic address"""
 
-        if len(params) != 3:
-            raise APIError(0, 'I need exactly 3 parameters.')
-        passphrase, addressVersionNumber, streamNumber = params
         numberOfAddresses = 1
         eighteenByteRipe = False
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         passphrase = self._decode(passphrase, "base64")
-        if addressVersionNumber != 3 and addressVersionNumber != 4:
+        if addressVersionNumber not in (3, 4):
             raise APIError(
                 2, 'The address version number currently must be 3 or 4. %i'
                 ' isn\'t supported.' % addressVersionNumber)
@@ -553,16 +588,11 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         ))
         return queues.apiAddressGeneratorReturnQueue.get()
 
-    def HandleCreateChan(self, params):
+    @command('createChan')
+    def HandleCreateChan(self, passphrase):
         """Handle a request to create a chan"""
 
-        if not params:
-            raise APIError(0, 'I need parameters.')
-
-        elif len(params) == 1:
-            passphrase, = params
         passphrase = self._decode(passphrase, "base64")
-
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
         # It would be nice to make the label the passphrase but it is
@@ -570,7 +600,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         try:
             unicode(passphrase, 'utf-8')
             label = str_chan + ' ' + passphrase
-        except BaseException:
+        except UnicodeDecodeError:
             label = str_chan + ' ' + repr(passphrase)
 
         addressVersionNumber = 4
@@ -583,18 +613,15 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             passphrase, True
         ))
         queueReturn = queues.apiAddressGeneratorReturnQueue.get()
-        if not queueReturn:
+        try:
+            return queueReturn[0]
+        except IndexError:
             raise APIError(24, 'Chan address is already present.')
-        address = queueReturn[0]
-        return address
 
-    def HandleJoinChan(self, params):
+    @command('joinChan')
+    def HandleJoinChan(self, passphrase, suppliedAddress):
         """Handle a request to join a chan"""
 
-        if len(params) < 2:
-            raise APIError(0, 'I need two parameters.')
-        elif len(params) == 2:
-            passphrase, suppliedAddress = params
         passphrase = self._decode(passphrase, "base64")
         if not passphrase:
             raise APIError(1, 'The specified passphrase is blank.')
@@ -603,122 +630,89 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         try:
             unicode(passphrase, 'utf-8')
             label = str_chan + ' ' + passphrase
-        except BaseException:
+        except UnicodeDecodeError:
             label = str_chan + ' ' + repr(passphrase)
 
-        status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(  # pylint: disable=unused-variable
-            suppliedAddress)
+        self._verifyAddress(suppliedAddress)
         suppliedAddress = addBMIfNotPresent(suppliedAddress)
         queues.apiAddressGeneratorReturnQueue.queue.clear()
         queues.addressGeneratorQueue.put((
             'joinChan', suppliedAddress, label, passphrase, True
         ))
-        addressGeneratorReturnValue = \
-            queues.apiAddressGeneratorReturnQueue.get()
-
-        if addressGeneratorReturnValue[0] == \
-                'chan name does not match address':
-            raise APIError(18, 'Chan name does not match address.')
-        if not addressGeneratorReturnValue:
+        queueReturn = queues.apiAddressGeneratorReturnQueue.get()
+        try:
+            if queueReturn[0] == 'chan name does not match address':
+                raise APIError(18, 'Chan name does not match address.')
+        except IndexError:
             raise APIError(24, 'Chan address is already present.')
+
         return "success"
 
-    def HandleLeaveChan(self, params):
+    @command('leaveChan')
+    def HandleLeaveChan(self, address):
         """Handle a request to leave a chan"""
-
-        if not params:
-            raise APIError(0, 'I need parameters.')
-        elif len(params) == 1:
-            address, = params
-            # pylint: disable=unused-variable
-            status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(address)
+        self._verifyAddress(address)
         address = addBMIfNotPresent(address)
-        if not BMConfigParser().has_section(address):
-            raise APIError(
-                13, 'Could not find this address in your keys.dat file.')
-        if not BMConfigParser().safeGetBoolean(address, 'chan'):
+        if not self.config.safeGetBoolean(address, 'chan'):
             raise APIError(
                 25, 'Specified address is not a chan address.'
                 ' Use deleteAddress API call instead.')
-        BMConfigParser().remove_section(address)
-        with open(state.appdata + 'keys.dat', 'wb') as configfile:
-            BMConfigParser().write(configfile)
-        return 'success'
+        try:
+            self.config.remove_section(address)
+        except ConfigParser.NoSectionError:
+            raise APIError(
+                13, 'Could not find this address in your keys.dat file.')
+        self.config.save()
+        queues.UISignalQueue.put(('rerenderMessagelistFromLabels', ''))
+        queues.UISignalQueue.put(('rerenderMessagelistToLabels', ''))
+        return "success"
 
-    def HandleDeleteAddress(self, params):
+    @command('deleteAddress')
+    def HandleDeleteAddress(self, address):
         """Handle a request to delete an address"""
-
-        if not params:
-            raise APIError(0, 'I need parameters.')
-        elif len(params) == 1:
-            address, = params
-        # pylint: disable=unused-variable
-        status, addressVersionNumber, streamNumber, toRipe = self._verifyAddress(address)
+        self._verifyAddress(address)
         address = addBMIfNotPresent(address)
-        if not BMConfigParser().has_section(address):
+        try:
+            self.config.remove_section(address)
+        except ConfigParser.NoSectionError:
             raise APIError(
                 13, 'Could not find this address in your keys.dat file.')
-        BMConfigParser().remove_section(address)
-        with open(state.appdata + 'keys.dat', 'wb') as configfile:
-            BMConfigParser().write(configfile)
+        self.config.save()
         queues.UISignalQueue.put(('rerenderMessagelistFromLabels', ''))
         queues.UISignalQueue.put(('rerenderMessagelistToLabels', ''))
         shared.reloadMyAddressHashes()
-        return 'success'
+        return "success"
 
-    def HandleGetAllInboxMessages(self, params):  # pylint: disable=unused-argument
+    @command('getAllInboxMessages')
+    def HandleGetAllInboxMessages(self):
         """Handle a request to get all inbox messages"""
 
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, received, message,"
-            " encodingtype, read FROM inbox where folder='inbox'"
+            " encodingtype, read FROM inbox WHERE folder='inbox'"
             " ORDER BY received"
         )
-        data = '{"inboxMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype, read = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received,
-                'read': read}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetAllInboxMessageIds(self, params):  # pylint: disable=unused-argument
+        return {"inboxMessages": [
+            self._dump_inbox_message(*data) for data in queryreturn
+        ]}
+
+    @command('getAllInboxMessageIds', 'getAllInboxMessageIDs')
+    def HandleGetAllInboxMessageIds(self):
         """Handle a request to get all inbox message IDs"""
 
         queryreturn = sqlQuery(
             "SELECT msgid FROM inbox where folder='inbox' ORDER BY received")
-        data = '{"inboxMessageIds":['
-        for row in queryreturn:
-            msgid = row[0]
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'msgid': hexlify(msgid)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetInboxMessageById(self, params):
+
+        return {"inboxMessageIds": [
+            {'msgid': hexlify(msgid)} for msgid, in queryreturn
+        ]}
+
+    @command('getInboxMessageById', 'getInboxMessageByID')
+    def HandleGetInboxMessageById(self, hid, readStatus=None):
         """Handle a request to get an inbox messsage by ID"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        elif len(params) == 1:
-            msgid = self._decode(params[0], "hex")
-        elif len(params) >= 2:
-            msgid = self._decode(params[0], "hex")
-            readStatus = params[1]
+        msgid = self._decode(hid, "hex")
+        if readStatus is not None:
             if not isinstance(readStatus, bool):
                 raise APIError(
                     23, 'Bool expected in readStatus, saw %s instead.' %
@@ -726,34 +720,26 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             queryreturn = sqlQuery(
                 "SELECT read FROM inbox WHERE msgid=?", msgid)
             # UPDATE is slow, only update if status is different
-            if queryreturn != [] and (queryreturn[0][0] == 1) != readStatus:
-                sqlExecute(
-                    "UPDATE inbox set read = ? WHERE msgid=?",
-                    readStatus, msgid)
-                queues.UISignalQueue.put(('changedInboxUnread', None))
+            try:
+                if (queryreturn[0][0] == 1) != readStatus:
+                    sqlExecute(
+                        "UPDATE inbox set read = ? WHERE msgid=?",
+                        readStatus, msgid)
+                    queues.UISignalQueue.put(('changedInboxUnread', None))
+            except KeyError:
+                pass
         queryreturn = sqlQuery(
-            "SELECT msgid, toaddress, fromaddress, subject, received, message,"
+            "SELECT toaddress, fromaddress, subject, received, message,"
             " encodingtype, read FROM inbox WHERE msgid=?", msgid
         )
-        data = '{"inboxMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype, read = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received,
-                'read': read}, indent=4, separators=(',', ': '))
-            data += ']}'
-            return data
-
-    def HandleGetAllSentMessages(self, params):  # pylint: disable=unused-argument
+        try:
+            return {"inboxMessage": [
+                self._dump_inbox_message(*queryreturn[0])]}
+        except KeyError:
+            pass  # FIXME inconsistent
+
+    @command('getAllSentMessages')
+    def HandleGetAllSentMessages(self):
         """Handle a request to get all sent messages"""
 
         queryreturn = sqlQuery(
@@ -761,217 +747,116 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE folder='sent' ORDER BY lastactiontime"
         )
-        data = '{"sentMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetAllSentMessageIds(self, params):  # pylint: disable=unused-argument
+        return {"sentMessages": [
+            self._dump_sent_message(*data) for data in queryreturn
+        ]}
+
+    @command('getAllSentMessageIds', 'getAllSentMessageIDs')
+    def HandleGetAllSentMessageIds(self):
         """Handle a request to get all sent message IDs"""
 
         queryreturn = sqlQuery(
-            "SELECT msgid FROM sent where folder='sent'"
+            "SELECT msgid FROM sent WHERE folder='sent'"
             " ORDER BY lastactiontime"
         )
-        data = '{"sentMessageIds":['
-        for row in queryreturn:
-            msgid = row[0]
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'msgid': hexlify(msgid)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleInboxMessagesByReceiver(self, params):
+        return {"sentMessageIds": [
+            {'msgid': hexlify(msgid)} for msgid, in queryreturn
+        ]}
+
+    # after some time getInboxMessagesByAddress should be removed
+    @command('getInboxMessagesByReceiver', 'legacy:getInboxMessagesByAddress')
+    def HandleInboxMessagesByReceiver(self, toAddress):
         """Handle a request to get inbox messages by receiver"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        toAddress = params[0]
         queryreturn = sqlQuery(
-            "SELECT msgid, toaddress, fromaddress, subject, received, message,"
-            " encodingtype FROM inbox WHERE folder='inbox' AND toAddress=?",
-            toAddress)
-        data = '{"inboxMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, received, message, \
-                encodingtype = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'receivedTime': received}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetSentMessageById(self, params):
+            "SELECT msgid, toaddress, fromaddress, subject, received,"
+            " message, encodingtype, read FROM inbox WHERE folder='inbox'"
+            " AND toAddress=?", toAddress)
+        return {"inboxMessages": [
+            self._dump_inbox_message(*data) for data in queryreturn
+        ]}
+
+    @command('getSentMessageById', 'getSentMessageByID')
+    def HandleGetSentMessageById(self, hid):
         """Handle a request to get a sent message by ID"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(hid, "hex")
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent WHERE msgid=?",
             msgid
         )
-        data = '{"sentMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-            data += ']}'
-            return data
-
-    def HandleGetSentMessagesByAddress(self, params):
+        try:
+            return {"sentMessage": [
+                self._dump_sent_message(*queryreturn[0])
+            ]}
+        except KeyError:
+            pass  # FIXME inconsistent
+
+    @command('getSentMessagesByAddress', 'getSentMessagesBySender')
+    def HandleGetSentMessagesByAddress(self, fromAddress):
         """Handle a request to get sent messages by address"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        fromAddress = params[0]
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE folder='sent' AND fromAddress=? ORDER BY lastactiontime",
             fromAddress
         )
-        data = '{"sentMessages":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row  # pylint: disable=unused-variable
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            if len(data) > 25:
-                data += ','
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleGetSentMessagesByAckData(self, params):
+        return {"sentMessages": [
+            self._dump_sent_message(*data) for data in queryreturn
+        ]}
+
+    @command('getSentMessageByAckData')
+    def HandleGetSentMessagesByAckData(self, ackData):
         """Handle a request to get sent messages by ack data"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        ackData = self._decode(params[0], "hex")
+        ackData = self._decode(ackData, "hex")
         queryreturn = sqlQuery(
             "SELECT msgid, toaddress, fromaddress, subject, lastactiontime,"
             " message, encodingtype, status, ackdata FROM sent"
             " WHERE ackdata=?", ackData
         )
-        data = '{"sentMessage":['
-        for row in queryreturn:
-            msgid, toAddress, fromAddress, subject, lastactiontime, message, \
-                encodingtype, status, ackdata = row
-            subject = shared.fixPotentiallyInvalidUTF8Data(subject)
-            message = shared.fixPotentiallyInvalidUTF8Data(message)
-            data += json.dumps({
-                'msgid': hexlify(msgid),
-                'toAddress': toAddress,
-                'fromAddress': fromAddress,
-                'subject': base64.b64encode(subject),
-                'message': base64.b64encode(message),
-                'encodingType': encodingtype,
-                'lastActionTime': lastactiontime,
-                'status': status,
-                'ackData': hexlify(ackdata)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleTrashMessage(self, params):
-        """Handle a request to trash a message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
 
+        try:
+            return {"sentMessage": [
+                self._dump_sent_message(*queryreturn[0])
+            ]}
+        except KeyError:
+            pass  # FIXME inconsistent
+
+    @command('trashMessage')
+    def HandleTrashMessage(self, msgid):
+        """Handle a request to trash a message by ID"""
+        msgid = self._decode(msgid, "hex")
         # Trash if in inbox table
         helper_inbox.trash(msgid)
         # Trash if in sent table
-        sqlExecute('''UPDATE sent SET folder='trash' WHERE msgid=?''', msgid)
+        sqlExecute("UPDATE sent SET folder='trash' WHERE msgid=?", msgid)
         return 'Trashed message (assuming message existed).'
 
-    def HandleTrashInboxMessage(self, params):
+    @command('trashInboxMessage')
+    def HandleTrashInboxMessage(self, msgid):
         """Handle a request to trash an inbox message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(msgid, "hex")
         helper_inbox.trash(msgid)
         return 'Trashed inbox message (assuming message existed).'
 
-    def HandleTrashSentMessage(self, params):
+    @command('trashSentMessage')
+    def HandleTrashSentMessage(self, msgid):
         """Handle a request to trash a sent message by ID"""
-
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        msgid = self._decode(params[0], "hex")
+        msgid = self._decode(msgid, "hex")
         sqlExecute('''UPDATE sent SET folder='trash' WHERE msgid=?''', msgid)
         return 'Trashed sent message (assuming message existed).'
 
-    def HandleSendMessage(self, params):
+    @command('sendMessage')
+    def HandleSendMessage(
+        self, toAddress, fromAddress, subject, message,
+        encodingType=2, TTL=4 * 24 * 60 * 60
+    ):
         """Handle a request to send a message"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        elif len(params) == 4:
-            toAddress, fromAddress, subject, message = params
-            encodingType = 2
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 5:
-            toAddress, fromAddress, subject, message, encodingType = params
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 6:
-            toAddress, fromAddress, subject, message, encodingType, TTL = \
-                params
-
-        if encodingType not in [2, 3]:
+        if encodingType not in (2, 3):
             raise APIError(6, 'The encoding type must be 2 or 3.')
         subject = self._decode(subject, "base64")
         message = self._decode(message, "base64")
@@ -983,12 +868,10 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             TTL = 28 * 24 * 60 * 60
         toAddress = addBMIfNotPresent(toAddress)
         fromAddress = addBMIfNotPresent(fromAddress)
-        # pylint: disable=unused-variable
-        status, addressVersionNumber, streamNumber, toRipe = \
-            self._verifyAddress(toAddress)
+        _, _, streamNumber, toRipe = self._verifyAddress(toAddress)
         self._verifyAddress(fromAddress)
         try:
-            fromAddressEnabled = BMConfigParser().getboolean(
+            fromAddressEnabled = self.config.getboolean(
                 fromAddress, 'enabled')
         except BaseException:
             raise APIError(
@@ -996,7 +879,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         if not fromAddressEnabled:
             raise APIError(14, 'Your fromAddress is disabled. Cannot send.')
 
-        stealthLevel = BMConfigParser().safeGetInt(
+        stealthLevel = self.config.safeGetInt(
             'bitmessagesettings', 'ackstealthlevel')
         ackdata = genAckPayload(streamNumber, stealthLevel)
 
@@ -1020,34 +903,24 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         toLabel = ''
         queryreturn = sqlQuery(
             "SELECT label FROM addressbook WHERE address=?", toAddress)
-        if queryreturn != []:
-            for row in queryreturn:
-                toLabel, = row
+        try:
+            toLabel, = queryreturn[0][0]
+        except KeyError:
+            pass
+
         queues.UISignalQueue.put(('displayNewSentMessage', (
             toAddress, toLabel, fromAddress, subject, message, ackdata)))
-
         queues.workerQueue.put(('sendmessage', toAddress))
 
         return hexlify(ackdata)
 
-    def HandleSendBroadcast(self, params):
+    @command('sendBroadcast')
+    def HandleSendBroadcast(
+        self, fromAddress, subject, message, encodingType=2,
+            TTL=4 * 24 * 60 * 60):
         """Handle a request to send a broadcast message"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-
-        if len(params) == 3:
-            fromAddress, subject, message = params
-            encodingType = 2
-            TTL = 4 * 24 * 60 * 60
-
-        elif len(params) == 4:
-            fromAddress, subject, message, encodingType = params
-            TTL = 4 * 24 * 60 * 60
-        elif len(params) == 5:
-            fromAddress, subject, message, encodingType, TTL = params
-
-        if encodingType not in [2, 3]:
+        if encodingType not in (2, 3):
             raise APIError(6, 'The encoding type must be 2 or 3.')
 
         subject = self._decode(subject, "base64")
@@ -1061,13 +934,13 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         fromAddress = addBMIfNotPresent(fromAddress)
         self._verifyAddress(fromAddress)
         try:
-            BMConfigParser().getboolean(fromAddress, 'enabled')
+            self.config.getboolean(fromAddress, 'enabled')
         except BaseException:
             raise APIError(
-                13, 'could not find your fromAddress in the keys.dat file.')
+                13, 'Could not find your fromAddress in the keys.dat file.')
         streamNumber = decodeAddress(fromAddress)[2]
         ackdata = genAckPayload(streamNumber, 0)
-        toAddress = '[Broadcast subscribers]'
+        toAddress = str_broadcast_subscribers
         ripe = ''
 
         t = ('',
@@ -1087,55 +960,45 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
              TTL)
         helper_sent.insert(t)
 
-        toLabel = '[Broadcast subscribers]'
+        toLabel = str_broadcast_subscribers
         queues.UISignalQueue.put(('displayNewSentMessage', (
             toAddress, toLabel, fromAddress, subject, message, ackdata)))
         queues.workerQueue.put(('sendbroadcast', ''))
 
         return hexlify(ackdata)
 
-    def HandleGetStatus(self, params):
+    @command('getStatus')
+    def HandleGetStatus(self, ackdata):
         """Handle a request to get the status of a sent message"""
 
-        if len(params) != 1:
-            raise APIError(0, 'I need one parameter!')
-        ackdata, = params
         if len(ackdata) < 76:
             # The length of ackData should be at least 38 bytes (76 hex digits)
             raise APIError(15, 'Invalid ackData object size.')
         ackdata = self._decode(ackdata, "hex")
         queryreturn = sqlQuery(
             "SELECT status FROM sent where ackdata=?", ackdata)
-        if queryreturn == []:
+        try:
+            return queryreturn[0][0]
+        except KeyError:
             return 'notfound'
-        for row in queryreturn:
-            status, = row
-            return status
 
-    def HandleAddSubscription(self, params):
+    @command('addSubscription')
+    def HandleAddSubscription(self, address, label=''):
         """Handle a request to add a subscription"""
 
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        if len(params) == 1:
-            address, = params
-            label = ''
-        if len(params) == 2:
-            address, label = params
+        if label:
             label = self._decode(label, "base64")
             try:
                 unicode(label, 'utf-8')
-            except BaseException:
+            except UnicodeDecodeError:
                 raise APIError(17, 'Label is not valid UTF-8 data.')
-        if len(params) > 2:
-            raise APIError(0, 'I need either 1 or 2 parameters!')
-        address = addBMIfNotPresent(address)
         self._verifyAddress(address)
+        address = addBMIfNotPresent(address)
         # First we must check to see if the address is already in the
         # subscriptions list.
         queryreturn = sqlQuery(
             "SELECT * FROM subscriptions WHERE address=?", address)
-        if queryreturn != []:
+        if queryreturn:
             raise APIError(16, 'You are already subscribed to that address.')
         sqlExecute(
             "INSERT INTO subscriptions VALUES (?,?,?)", label, address, True)
@@ -1144,37 +1007,37 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         queues.UISignalQueue.put(('rerenderSubscriptions', ''))
         return 'Added subscription.'
 
-    def HandleDeleteSubscription(self, params):
+    @command('deleteSubscription')
+    def HandleDeleteSubscription(self, address):
         """Handle a request to delete a subscription"""
 
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        address, = params
         address = addBMIfNotPresent(address)
-        sqlExecute('''DELETE FROM subscriptions WHERE address=?''', address)
+        sqlExecute("DELETE FROM subscriptions WHERE address=?", address)
         shared.reloadBroadcastSendersForWhichImWatching()
         queues.UISignalQueue.put(('rerenderMessagelistFromLabels', ''))
         queues.UISignalQueue.put(('rerenderSubscriptions', ''))
         return 'Deleted subscription if it existed.'
 
-    def ListSubscriptions(self, params):  # pylint: disable=unused-argument
+    @command('listSubscriptions')
+    def ListSubscriptions(self):
         """Handle a request to list susbcriptions"""
 
-        # pylint: disable=unused-variable
         queryreturn = sqlQuery(
             "SELECT label, address, enabled FROM subscriptions")
-        data = {'subscriptions': []}
-        for row in queryreturn:
-            label, address, enabled = row
+        data = []
+        for label, address, enabled in queryreturn:
             label = shared.fixPotentiallyInvalidUTF8Data(label)
-            data['subscriptions'].append({
+            data.append({
                 'label': base64.b64encode(label),
                 'address': address,
                 'enabled': enabled == 1
             })
-        return json.dumps(data, indent=4, separators=(',', ': '))
+        return {'subscriptions': data}
 
-    def HandleDisseminatePreEncryptedMsg(self, params):
+    @command('disseminatePreEncryptedMsg')
+    def HandleDisseminatePreEncryptedMsg(
+        self, encryptedPayload, requiredAverageProofOfWorkNonceTrialsPerByte,
+            requiredPayloadLengthExtraBytes):
         """Handle a request to disseminate an encrypted message"""
 
         # The device issuing this command to PyBitmessage supplies a msg
@@ -1182,38 +1045,28 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # to be done. PyBitmessage accepts this msg object and sends it out
         # to the rest of the Bitmessage network as if it had generated
         # the message itself. Please do not yet add this to the api doc.
-        if len(params) != 3:
-            raise APIError(0, 'I need 3 parameter!')
-        encryptedPayload, requiredAverageProofOfWorkNonceTrialsPerByte, \
-            requiredPayloadLengthExtraBytes = params
         encryptedPayload = self._decode(encryptedPayload, "hex")
         # Let us do the POW and attach it to the front
-        target = 2**64 / (
-            (
-                len(encryptedPayload) + requiredPayloadLengthExtraBytes + 8
-            ) * requiredAverageProofOfWorkNonceTrialsPerByte
+        target = 2**64 / ((
+            len(encryptedPayload) + requiredPayloadLengthExtraBytes + 8) *
+            requiredAverageProofOfWorkNonceTrialsPerByte)
+        logger.warning(
+            '(For msg message via API) Doing proof of work. Total  required'
+            ' difficulty: %s\nRequired small message difficulty: %s',
+            float(requiredAverageProofOfWorkNonceTrialsPerByte) /
+            defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
+            float(requiredPayloadLengthExtraBytes) /
+            defaults.networkDefaultPayloadLengthExtraBytes,
         )
-        with shared.printLock:
-            print(
-                '(For msg message via API) Doing proof of work. Total required difficulty:',
-                float(
-                    requiredAverageProofOfWorkNonceTrialsPerByte
-                ) / defaults.networkDefaultProofOfWorkNonceTrialsPerByte,
-                'Required small message difficulty:',
-                float(requiredPayloadLengthExtraBytes) / defaults.networkDefaultPayloadLengthExtraBytes,
-            )
         powStartTime = time.time()
         initialHash = hashlib.sha512(encryptedPayload).digest()
         trialValue, nonce = proofofwork.run(target, initialHash)
-        with shared.printLock:
-            print '(For msg message via API) Found proof of work', trialValue, 'Nonce:', nonce
-            try:
-                print(
-                    'POW took', int(time.time() - powStartTime), 'seconds.',
-                    nonce / (time.time() - powStartTime), 'nonce trials per second.',
-                )
-            except BaseException:
-                pass
+        logger.warning(
+            '(For msg message via API) Found proof of work %s\nNonce: %s\n'
+            'POW took %s seconds. %s nonce trials per second.',
+            trialValue, nonce, int(time.time() - powStartTime),
+            nonce / (time.time() - powStartTime)
+        )
         encryptedPayload = pack('>Q', nonce) + encryptedPayload
         toStreamNumber = decodeVarint(encryptedPayload[16:26])[0]
         inventoryHash = calculateInventoryHash(encryptedPayload)
@@ -1223,21 +1076,21 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             objectType, toStreamNumber, encryptedPayload,
             int(time.time()) + TTL, ''
         )
-        with shared.printLock:
-            print 'Broadcasting inv for msg(API disseminatePreEncryptedMsg command):', hexlify(inventoryHash)
+        logger.warning(
+            'Broadcasting inv for msg(API disseminatePreEncryptedMsg'
+            ' command): %s', hexlify(inventoryHash))
         queues.invQueue.put((toStreamNumber, inventoryHash))
 
-    def HandleTrashSentMessageByAckDAta(self, params):
+    @command('trashSentMessageByAckData')
+    def HandleTrashSentMessageByAckDAta(self, ackdata):
         """Handle a request to trash a sent message by ackdata"""
-
         # This API method should only be used when msgid is not available
-        if not params:
-            raise APIError(0, 'I need parameters!')
-        ackdata = self._decode(params[0], "hex")
+        ackdata = self._decode(ackdata, "hex")
         sqlExecute("UPDATE sent SET folder='trash' WHERE ackdata=?", ackdata)
         return 'Trashed sent message (assuming message existed).'
 
-    def HandleDissimatePubKey(self, params):  # pylint: disable=unused-argument
+    @command('disseminatePubkey')
+    def HandleDissimatePubKey(self, payload):
         """Handle a request to disseminate a public key"""
 
         # The device issuing this command to PyBitmessage supplies a pubkey
@@ -1245,19 +1098,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         # PyBitmessage accepts this pubkey object and sends it out to the rest
         # of the Bitmessage network as if it had generated the pubkey object
         # itself. Please do not yet add this to the api doc.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        payload, = params
         payload = self._decode(payload, "hex")
 
         # Let us do the POW
         target = 2 ** 64 / ((
             len(payload) + defaults.networkDefaultPayloadLengthExtraBytes + 8
         ) * defaults.networkDefaultProofOfWorkNonceTrialsPerByte)
-        print '(For pubkey message via API) Doing proof of work...'
+        logger.warning('(For pubkey message via API) Doing proof of work...')
         initialHash = hashlib.sha512(payload).digest()
         trialValue, nonce = proofofwork.run(target, initialHash)
-        print '(For pubkey message via API) Found proof of work', trialValue, 'Nonce:', nonce
+        logger.warning(
+            '(For pubkey message via API) Found proof of work %s Nonce: %s',
+            trialValue, nonce
+        )
         payload = pack('>Q', nonce) + payload
 
         pubkeyReadPosition = 8  # bypass the nonce
@@ -1267,8 +1120,8 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         else:
             pubkeyReadPosition += 4
         # pylint: disable=unused-variable
-        addressVersion, addressVersionLength = decodeVarint(
-            payload[pubkeyReadPosition:pubkeyReadPosition + 10])
+        addressVersionLength = decodeVarint(
+            payload[pubkeyReadPosition:pubkeyReadPosition + 10])[1]
         pubkeyReadPosition += addressVersionLength
         pubkeyStreamNumber = decodeVarint(
             payload[pubkeyReadPosition:pubkeyReadPosition + 10])[0]
@@ -1278,19 +1131,19 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
         Inventory()[inventoryHash] = (
             objectType, pubkeyStreamNumber, payload, int(time.time()) + TTL, ''
         )
-        with shared.printLock:
-            print 'broadcasting inv within API command disseminatePubkey with hash:', hexlify(inventoryHash)
+        logger.warning(
+            'broadcasting inv within API command disseminatePubkey with'
+            ' hash: %s', hexlify(inventoryHash))
         queues.invQueue.put((pubkeyStreamNumber, inventoryHash))
 
-    def HandleGetMessageDataByDestinationHash(self, params):
+    @command(
+        'getMessageDataByDestinationHash', 'getMessageDataByDestinationTag')
+    def HandleGetMessageDataByDestinationHash(self, requestedHash):
         """Handle a request to get message data by destination hash"""
 
         # Method will eventually be used by a particular Android app to
         # select relevant messages. Do not yet add this to the api
         # doc.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        requestedHash, = params
         if len(requestedHash) != 32:
             raise APIError(
                 19, 'The length of hash should be 32 bytes (encoded in hex'
@@ -1304,8 +1157,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             "SELECT hash, payload FROM inventory WHERE tag = ''"
             " and objecttype = 2")
         with SqlBulkExecute() as sql:
-            for row in queryreturn:
-                hash01, payload = row
+            for hash01, payload in queryreturn:
                 readPosition = 16  # Nonce length + time length
                 # Stream Number length
                 readPosition += decodeVarint(
@@ -1315,17 +1167,12 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
 
         queryreturn = sqlQuery(
             "SELECT payload FROM inventory WHERE tag = ?", requestedHash)
-        data = '{"receivedMessageDatas":['
-        for row in queryreturn:
-            payload, = row
-            if len(data) > 25:
-                data += ','
-            data += json.dumps(
-                {'data': hexlify(payload)}, indent=4, separators=(',', ': '))
-        data += ']}'
-        return data
-
-    def HandleClientStatus(self, params):  # pylint: disable=unused-argument
+        return {"receivedMessageDatas": [
+            {'data': hexlify(payload)} for payload, in queryreturn
+        ]}
+
+    @command('clientStatus')
+    def HandleClientStatus(self):
         """Handle a request to get the status of the client"""
 
         connections_num = len(network.stats.connectedHostsList())
@@ -1335,7 +1182,7 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             networkStatus = 'connectedAndReceivingIncomingConnections'
         else:
             networkStatus = 'connectedButHaveNotReceivedIncomingConnections'
-        return json.dumps({
+        return {
             'networkConnections': connections_num,
             'numberOfMessagesProcessed': shared.numberOfMessagesProcessed,
             'numberOfBroadcastsProcessed': shared.numberOfBroadcastsProcessed,
@@ -1343,140 +1190,88 @@ class MySimpleXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
             'networkStatus': networkStatus,
             'softwareName': 'PyBitmessage',
             'softwareVersion': softwareVersion
-        }, indent=4, separators=(',', ': '))
-
-    def HandleDecodeAddress(self, params):
-        """Handle a request to decode an address"""
-
-        # Return a meaningful decoding of an address.
-        if len(params) != 1:
-            raise APIError(0, 'I need 1 parameter!')
-        address, = params
-        status, addressVersion, streamNumber, ripe = decodeAddress(address)
-        return json.dumps({
-            'status': status,
-            'addressVersion': addressVersion,
-            'streamNumber': streamNumber,
-            'ripe': base64.b64encode(ripe)
-        }, indent=4, separators=(',', ': '))
+        }
 
-    def HandleHelloWorld(self, params):
+    @command('helloWorld')
+    def HandleHelloWorld(self, a, b):
         """Test two string params"""
-
-        a, b = params
         return a + '-' + b
 
-    def HandleAdd(self, params):
+    @command('add')
+    def HandleAdd(self, a, b):
         """Test two numeric params"""
-
-        a, b = params
         return a + b
 
-    def HandleStatusBar(self, params):
+    @command('statusBar')
+    def HandleStatusBar(self, message):
         """Handle a request to update the status bar"""
-
-        message, = params
         queues.UISignalQueue.put(('updateStatusBar', message))
 
-    def HandleDeleteAndVacuum(self, params):
+    @command('deleteAndVacuum')
+    def HandleDeleteAndVacuum(self):
         """Handle a request to run the deleteandvacuum stored procedure"""
+        sqlStoredProcedure('deleteandvacuume')
+        return 'done'
 
-        if not params:
-            sqlStoredProcedure('deleteandvacuume')
-            return 'done'
-        return None
-
-    def HandleShutdown(self, params):
-        """Handle a request to huutdown the client"""
-
-        if not params:
-            shutdown.doCleanShutdown()
-            return 'done'
-        return None
-
-    handlers = {}
-    handlers['helloWorld'] = HandleHelloWorld
-    handlers['add'] = HandleAdd
-    handlers['statusBar'] = HandleStatusBar
-    handlers['listAddresses'] = HandleListAddresses
-    handlers['listAddressBookEntries'] = HandleListAddressBookEntries
-    # the listAddressbook alias should be removed eventually.
-    handlers['listAddressbook'] = HandleListAddressBookEntries
-    handlers['addAddressBookEntry'] = HandleAddAddressBookEntry
-    # the addAddressbook alias should be deleted eventually.
-    handlers['addAddressbook'] = HandleAddAddressBookEntry
-    handlers['deleteAddressBookEntry'] = HandleDeleteAddressBookEntry
-    # The deleteAddressbook alias should be deleted eventually.
-    handlers['deleteAddressbook'] = HandleDeleteAddressBookEntry
-    handlers['createRandomAddress'] = HandleCreateRandomAddress
-    handlers['createDeterministicAddresses'] = \
-        HandleCreateDeterministicAddresses
-    handlers['getDeterministicAddress'] = HandleGetDeterministicAddress
-    handlers['createChan'] = HandleCreateChan
-    handlers['joinChan'] = HandleJoinChan
-    handlers['leaveChan'] = HandleLeaveChan
-    handlers['deleteAddress'] = HandleDeleteAddress
-    handlers['getAllInboxMessages'] = HandleGetAllInboxMessages
-    handlers['getAllInboxMessageIds'] = HandleGetAllInboxMessageIds
-    handlers['getAllInboxMessageIDs'] = HandleGetAllInboxMessageIds
-    handlers['getInboxMessageById'] = HandleGetInboxMessageById
-    handlers['getInboxMessageByID'] = HandleGetInboxMessageById
-    handlers['getAllSentMessages'] = HandleGetAllSentMessages
-    handlers['getAllSentMessageIds'] = HandleGetAllSentMessageIds
-    handlers['getAllSentMessageIDs'] = HandleGetAllSentMessageIds
-    handlers['getInboxMessagesByReceiver'] = HandleInboxMessagesByReceiver
-    # after some time getInboxMessagesByAddress should be removed
-    handlers['getInboxMessagesByAddress'] = HandleInboxMessagesByReceiver
-    handlers['getSentMessageById'] = HandleGetSentMessageById
-    handlers['getSentMessageByID'] = HandleGetSentMessageById
-    handlers['getSentMessagesByAddress'] = HandleGetSentMessagesByAddress
-    handlers['getSentMessagesBySender'] = HandleGetSentMessagesByAddress
-    handlers['getSentMessageByAckData'] = HandleGetSentMessagesByAckData
-    handlers['trashMessage'] = HandleTrashMessage
-    handlers['trashInboxMessage'] = HandleTrashInboxMessage
-    handlers['trashSentMessage'] = HandleTrashSentMessage
-    handlers['trashSentMessageByAckData'] = HandleTrashSentMessageByAckDAta
-    handlers['sendMessage'] = HandleSendMessage
-    handlers['sendBroadcast'] = HandleSendBroadcast
-    handlers['getStatus'] = HandleGetStatus
-    handlers['addSubscription'] = HandleAddSubscription
-    handlers['deleteSubscription'] = HandleDeleteSubscription
-    handlers['listSubscriptions'] = ListSubscriptions
-    handlers['disseminatePreEncryptedMsg'] = HandleDisseminatePreEncryptedMsg
-    handlers['disseminatePubkey'] = HandleDissimatePubKey
-    handlers['getMessageDataByDestinationHash'] = \
-        HandleGetMessageDataByDestinationHash
-    handlers['getMessageDataByDestinationTag'] = \
-        HandleGetMessageDataByDestinationHash
-    handlers['clientStatus'] = HandleClientStatus
-    handlers['decodeAddress'] = HandleDecodeAddress
-    handlers['deleteAndVacuum'] = HandleDeleteAndVacuum
-    handlers['shutdown'] = HandleShutdown
+    @command('shutdown')
+    def HandleShutdown(self):
+        """Handle a request to shutdown the node"""
+        shutdown.doCleanShutdown()
+        return 'done'
 
     def _handle_request(self, method, params):
-        if method not in self.handlers:
+        try:
+            self._method = method
+            func = self._handlers[method]
+            return func(self, *params)
+        except KeyError:
             raise APIError(20, 'Invalid method: %s' % method)
-        result = self.handlers[method](self, params)
-        state.last_api_response = time.time()
-        return result
+        except TypeError as e:
+            msg = 'Unexpected API Failure - %s' % e
+            if 'argument' not in str(e):
+                raise APIError(0, msg)
+            argcount = len(params)
+            maxcount = func.func_code.co_argcount
+            if argcount > maxcount:
+                msg = (
+                    'Command %s takes at most %s parameters (%s given)' %
+                    (method, maxcount, argcount))
+            else:
+                mincount = maxcount - len(func.func_defaults or [])
+                if argcount < mincount:
+                    msg = (
+                        'Command %s takes at least %s parameters (%s given)' %
+                        (method, mincount, argcount))
+            raise APIError(0, msg)
+        finally:
+            state.last_api_response = time.time()
 
     def _dispatch(self, method, params):
-        # pylint: disable=attribute-defined-outside-init
-        self.cookies = []
-
-        validuser = self.APIAuthenticateClient()
-        if not validuser:
-            time.sleep(2)
-            return "RPC Username or password incorrect or HTTP header lacks authentication at all."
+        _fault = None
 
         try:
             return self._handle_request(method, params)
         except APIError as e:
-            return str(e)
+            _fault = e
         except varintDecodeError as e:
             logger.error(e)
-            return "API Error 0026: Data contains a malformed varint. Some details: %s" % e
+            _fault = APIError(
+                26, 'Data contains a malformed varint. Some details: %s' %
+                e)
         except Exception as e:
             logger.exception(e)
+            _fault = APIError(21, 'Unexpected API Failure - %s' % e)
+
+        if _fault:
+            if self.config.safeGet(
+                    'bitmessagesettings', 'apivariant') == 'legacy':
+                return str(_fault)
+            else:
+                raise _fault  # pylint: disable=raising-bad-type
+
+    def _listMethods(self):
+        """List all API commands"""
+        return self._handlers.keys()
 
-            return "API Error 0021: Unexpected API Failure - %s" % e
+    def _methodHelp(self, method):
+        return self._handlers[method].__doc__
diff --git a/src/bitmessagemain.py b/src/bitmessagemain.py
index 2c3d10db..71c6c7e1 100755
--- a/src/bitmessagemain.py
+++ b/src/bitmessagemain.py
@@ -199,6 +199,8 @@ class Main:
                     'bitmessagesettings', 'apiusername', 'username')
                 config.set(
                     'bitmessagesettings', 'apipassword', 'password')
+                config.set(
+                    'bitmessagesettings', 'apivariant', 'legacy')
                 config.set(
                     'bitmessagesettings', 'apinotifypath',
                     os.path.join(app_dir, 'tests', 'apinotify_handler.py')
diff --git a/src/tests/test_api.py b/src/tests/test_api.py
index 2bb6d0ce..61cc0edf 100644
--- a/src/tests/test_api.py
+++ b/src/tests/test_api.py
@@ -36,11 +36,8 @@ class TestAPI(TestProcessProto):
     def test_user_password(self):
         """Trying to connect with wrong username/password"""
         api_wrong = xmlrpclib.ServerProxy("http://test:wrong@127.0.0.1:8442/")
-        self.assertEqual(
-            api_wrong.clientStatus(),
-            'RPC Username or password incorrect or HTTP header lacks'
-            ' authentication at all.'
-        )
+        with self.assertRaises(xmlrpclib.ProtocolError):
+            api_wrong.clientStatus()
 
     def test_connection(self):
         """API command 'helloWorld'"""
diff --git a/src/translations/bitmessage_zh_cn.qm b/src/translations/bitmessage_zh_cn.qm
index 15bd483a..6a77636d 100644
Binary files a/src/translations/bitmessage_zh_cn.qm and b/src/translations/bitmessage_zh_cn.qm differ
diff --git a/src/translations/bitmessage_zh_cn.ts b/src/translations/bitmessage_zh_cn.ts
index 86379635..60c999bf 100644
--- a/src/translations/bitmessage_zh_cn.ts
+++ b/src/translations/bitmessage_zh_cn.ts
@@ -60,27 +60,27 @@
         <translation>@mailchuck.com</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="307"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="286"/>
         <source>Registration failed:</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="309"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="288"/>
         <source>The requested email address is not available, please try a new one.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="356"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="334"/>
         <source>Sending email gateway registration request</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="364"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="342"/>
         <source>Sending email gateway unregistration request</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="370"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="348"/>
         <source>Sending email gateway status request</source>
         <translation></translation>
     </message>
@@ -356,7 +356,7 @@ Please type the desired email address (including @mailchuck.com) below:</source>
         <translation>, %1,1. 1. ?</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1030"/>
+        <location filename="../bitmessageqt/__init__.py" line="1042"/>
         <source>Waiting for their encryption key. Will request it again soon.</source>
         <translation></translation>
     </message>
@@ -366,17 +366,17 @@ Please type the desired email address (including @mailchuck.com) below:</source>
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1036"/>
+        <location filename="../bitmessageqt/__init__.py" line="1048"/>
         <source>Queued.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1039"/>
+        <location filename="../bitmessageqt/__init__.py" line="1051"/>
         <source>Message sent. Waiting for acknowledgement. Sent at %1</source>
         <translation>. .  %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1042"/>
+        <location filename="../bitmessageqt/__init__.py" line="1054"/>
         <source>Message sent. Sent at %1</source>
         <translation>.  %1</translation>
     </message>
@@ -386,47 +386,47 @@ Please type the desired email address (including @mailchuck.com) below:</source>
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1048"/>
+        <location filename="../bitmessageqt/__init__.py" line="1060"/>
         <source>Acknowledgement of the message received %1</source>
         <translation> %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2140"/>
+        <location filename="../bitmessageqt/__init__.py" line="2152"/>
         <source>Broadcast queued.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1057"/>
+        <location filename="../bitmessageqt/__init__.py" line="1069"/>
         <source>Broadcast on %1</source>
         <translation> %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1060"/>
+        <location filename="../bitmessageqt/__init__.py" line="1072"/>
         <source>Problem: The work demanded by the recipient is more difficult than you are willing to do. %1</source>
         <translation>  %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1063"/>
+        <location filename="../bitmessageqt/__init__.py" line="1075"/>
         <source>Problem: The recipient&apos;s encryption key is no good. Could not encrypt message. %1</source>
         <translation>  %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1066"/>
+        <location filename="../bitmessageqt/__init__.py" line="1078"/>
         <source>Forced difficulty override. Send should start soon.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1069"/>
+        <location filename="../bitmessageqt/__init__.py" line="1081"/>
         <source>Unknown status: %1 %2</source>
         <translation> %1 %2</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1610"/>
+        <location filename="../bitmessageqt/__init__.py" line="1622"/>
         <source>Not Connected</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1200"/>
+        <location filename="../bitmessageqt/__init__.py" line="1212"/>
         <source>Show Bitmessage</source>
         <translation></translation>
     </message>
@@ -436,12 +436,12 @@ Please type the desired email address (including @mailchuck.com) below:</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1223"/>
+        <location filename="../bitmessageqt/__init__.py" line="1235"/>
         <source>Subscribe</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1229"/>
+        <location filename="../bitmessageqt/__init__.py" line="1241"/>
         <source>Channel</source>
         <translation></translation>
     </message>
@@ -451,66 +451,66 @@ Please type the desired email address (including @mailchuck.com) below:</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1455"/>
+        <location filename="../bitmessageqt/__init__.py" line="1467"/>
         <source>You may manage your keys by editing the keys.dat file stored in the same directory as this program. It is important that you back up this file.</source>
         <translation> keys.dat  </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1459"/>
+        <location filename="../bitmessageqt/__init__.py" line="1471"/>
         <source>You may manage your keys by editing the keys.dat file stored in
  %1 
 It is important that you back up this file.</source>
         <translation> %1  keys.dat </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1466"/>
+        <location filename="../bitmessageqt/__init__.py" line="1478"/>
         <source>Open keys.dat?</source>
         <translation> keys.dat  </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1463"/>
+        <location filename="../bitmessageqt/__init__.py" line="1475"/>
         <source>You may manage your keys by editing the keys.dat file stored in the same directory as this program. It is important that you back up this file. Would you like to open the file now? (Be sure to close Bitmessage before making any changes.)</source>
         <translation> keys.dat </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1466"/>
+        <location filename="../bitmessageqt/__init__.py" line="1478"/>
         <source>You may manage your keys by editing the keys.dat file stored in
  %1 
 It is important that you back up this file. Would you like to open the file now? (Be sure to close Bitmessage before making any changes.)</source>
         <translation> %1  keys.dat </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1473"/>
+        <location filename="../bitmessageqt/__init__.py" line="1485"/>
         <source>Delete trash?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1473"/>
+        <location filename="../bitmessageqt/__init__.py" line="1485"/>
         <source>Are you sure you want to delete all trashed messages?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1491"/>
+        <location filename="../bitmessageqt/__init__.py" line="1503"/>
         <source>bad passphrase</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1491"/>
+        <location filename="../bitmessageqt/__init__.py" line="1503"/>
         <source>You must type your passphrase. If you don&apos;t have one then this is not the form for you.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1514"/>
+        <location filename="../bitmessageqt/__init__.py" line="1526"/>
         <source>Bad address version number</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1504"/>
+        <location filename="../bitmessageqt/__init__.py" line="1516"/>
         <source>Your address version number must be a number: either 3 or 4.</source>
         <translation> 3  4.</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1514"/>
+        <location filename="../bitmessageqt/__init__.py" line="1526"/>
         <source>Your address version number must be either 3 or 4.</source>
         <translation> 3  4.</translation>
     </message>
@@ -580,22 +580,22 @@ It is important that you back up this file. Would you like to open the file now?
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1595"/>
+        <location filename="../bitmessageqt/__init__.py" line="1607"/>
         <source>Connection lost</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1645"/>
+        <location filename="../bitmessageqt/__init__.py" line="1657"/>
         <source>Connected</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1765"/>
+        <location filename="../bitmessageqt/__init__.py" line="1777"/>
         <source>Message trashed</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1854"/>
+        <location filename="../bitmessageqt/__init__.py" line="1866"/>
         <source>The TTL, or Time-To-Live is the length of time that the network will hold the message.
  The recipient must get it during this time. If your Bitmessage client does not hear an acknowledgement, it
  will resend the message automatically. The longer the Time-To-Live, the
@@ -604,17 +604,17 @@ It is important that you back up this file. Would you like to open the file now?
 . Bitmessage, . Time-To-Live, .  Time-To-Time, .</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1899"/>
+        <location filename="../bitmessageqt/__init__.py" line="1911"/>
         <source>Message too long</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1899"/>
+        <location filename="../bitmessageqt/__init__.py" line="1911"/>
         <source>The message that you are trying to send is too long by %1 bytes. (The maximum is 261644 bytes). Please cut it down before sending.</source>
         <translation> 1 261644</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1941"/>
+        <location filename="../bitmessageqt/__init__.py" line="1953"/>
         <source>Error: Your account wasn&apos;t registered at an email gateway. Sending registration now as %1, please wait for the registration to be processed before retrying sending.</source>
         <translation>: 1, .</translation>
     </message>
@@ -659,57 +659,57 @@ It is important that you back up this file. Would you like to open the file now?
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2092"/>
+        <location filename="../bitmessageqt/__init__.py" line="2104"/>
         <source>Error: You must specify a From address. If you don&apos;t have one, go to the &apos;Your Identities&apos; tab.</source>
         <translation>  </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2026"/>
+        <location filename="../bitmessageqt/__init__.py" line="2038"/>
         <source>Address version number</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2026"/>
+        <location filename="../bitmessageqt/__init__.py" line="2038"/>
         <source>Concerning the address %1, Bitmessage cannot understand address version numbers of %2. Perhaps upgrade Bitmessage to the latest version.</source>
         <translation> %1  %2 </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2030"/>
+        <location filename="../bitmessageqt/__init__.py" line="2042"/>
         <source>Stream number</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2030"/>
+        <location filename="../bitmessageqt/__init__.py" line="2042"/>
         <source>Concerning the address %1, Bitmessage cannot handle stream numbers of %2. Perhaps upgrade Bitmessage to the latest version.</source>
         <translation> %1  %2 </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2035"/>
+        <location filename="../bitmessageqt/__init__.py" line="2047"/>
         <source>Warning: You are currently not connected. Bitmessage will do the work necessary to send the message but it won&apos;t send until you connect.</source>
         <translation>  </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2084"/>
+        <location filename="../bitmessageqt/__init__.py" line="2096"/>
         <source>Message queued.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2088"/>
+        <location filename="../bitmessageqt/__init__.py" line="2100"/>
         <source>Your &apos;To&apos; field is empty.</source>
         <translation>&quot;</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2149"/>
+        <location filename="../bitmessageqt/__init__.py" line="2161"/>
         <source>Right click one or more entries in your address book and select &apos;Send message to this address&apos;.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2164"/>
+        <location filename="../bitmessageqt/__init__.py" line="2177"/>
         <source>Fetched address from namecoin identity.</source>
         <translation>namecoin</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2276"/>
+        <location filename="../bitmessageqt/__init__.py" line="2289"/>
         <source>New Message</source>
         <translation></translation>
     </message>
@@ -734,47 +734,47 @@ It is important that you back up this file. Would you like to open the file now?
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2306"/>
+        <location filename="../bitmessageqt/__init__.py" line="2319"/>
         <source>Error: You cannot add the same address to your address book twice. Try renaming the existing one if you want.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3364"/>
+        <location filename="../bitmessageqt/__init__.py" line="3346"/>
         <source>Error: You cannot add the same address to your subscriptions twice. Perhaps rename the existing one if you want.</source>
         <translation>: . .</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2428"/>
+        <location filename="../bitmessageqt/__init__.py" line="2441"/>
         <source>Restart</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2414"/>
+        <location filename="../bitmessageqt/__init__.py" line="2427"/>
         <source>You must restart Bitmessage for the port number change to take effect.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2428"/>
+        <location filename="../bitmessageqt/__init__.py" line="2441"/>
         <source>Bitmessage will use your proxy from now on but you may want to manually restart Bitmessage now to close existing connections (if any).</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2457"/>
+        <location filename="../bitmessageqt/__init__.py" line="2470"/>
         <source>Number needed</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2457"/>
+        <location filename="../bitmessageqt/__init__.py" line="2470"/>
         <source>Your maximum download and upload rate must be numbers. Ignoring what you typed.</source>
         <translation>. .</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2538"/>
+        <location filename="../bitmessageqt/__init__.py" line="2550"/>
         <source>Will not resend ever</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2538"/>
+        <location filename="../bitmessageqt/__init__.py" line="2550"/>
         <source>Note that the time limit you entered is less than the amount of time Bitmessage waits for the first resend attempt therefore your messages will never be resent.</source>
         <translation></translation>
     </message>
@@ -789,42 +789,42 @@ It is important that you back up this file. Would you like to open the file now?
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="152"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="136"/>
         <source>Passphrase mismatch</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="152"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="136"/>
         <source>The passphrase you entered twice doesn&apos;t match. Try again.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="160"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="144"/>
         <source>Choose a passphrase</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="160"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="144"/>
         <source>You really do need a passphrase.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3043"/>
+        <location filename="../bitmessageqt/__init__.py" line="3025"/>
         <source>Address is gone</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3043"/>
+        <location filename="../bitmessageqt/__init__.py" line="3025"/>
         <source>Bitmessage cannot find your address %1. Perhaps you removed it?</source>
         <translation> %1 </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3046"/>
+        <location filename="../bitmessageqt/__init__.py" line="3028"/>
         <source>Address disabled</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3046"/>
+        <location filename="../bitmessageqt/__init__.py" line="3028"/>
         <source>Error: The address from which you are trying to send is disabled. You&apos;ll have to enable it on the &apos;Your Identities&apos; tab before using it.</source>
         <translation> </translation>
     </message>
@@ -834,42 +834,42 @@ It is important that you back up this file. Would you like to open the file now?
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3121"/>
+        <location filename="../bitmessageqt/__init__.py" line="3103"/>
         <source>Entry added to the blacklist. Edit the label to your liking.</source>
         <translation>. .</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3126"/>
+        <location filename="../bitmessageqt/__init__.py" line="3108"/>
         <source>Error: You cannot add the same address to your blacklist twice. Try renaming the existing one if you want.</source>
         <translation>: .  .</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3268"/>
+        <location filename="../bitmessageqt/__init__.py" line="3250"/>
         <source>Moved items to trash.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3212"/>
+        <location filename="../bitmessageqt/__init__.py" line="3194"/>
         <source>Undeleted item.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3236"/>
+        <location filename="../bitmessageqt/__init__.py" line="3218"/>
         <source>Save As...</source>
         <translation>...</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3245"/>
+        <location filename="../bitmessageqt/__init__.py" line="3227"/>
         <source>Write error.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3348"/>
+        <location filename="../bitmessageqt/__init__.py" line="3330"/>
         <source>No addresses selected.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3403"/>
+        <location filename="../bitmessageqt/__init__.py" line="3385"/>
         <source>If you delete the subscription, messages that you already received will become inaccessible. Maybe you can consider disabling the subscription instead. Disabled subscriptions will not receive new messages, but you can still view messages you already received.
 
 Are you sure you want to delete the subscription?</source>
@@ -878,7 +878,7 @@ Are you sure you want to delete the subscription?</source>
 ?</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3650"/>
+        <location filename="../bitmessageqt/__init__.py" line="3632"/>
         <source>If you delete the channel, messages that you already received will become inaccessible. Maybe you can consider disabling the channel instead. Disabled channels will not receive new messages, but you can still view messages you already received.
 
 Are you sure you want to delete the channel?</source>
@@ -887,32 +887,32 @@ Are you sure you want to delete the channel?</source>
 </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3780"/>
+        <location filename="../bitmessageqt/__init__.py" line="3762"/>
         <source>Do you really want to remove this avatar?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3788"/>
+        <location filename="../bitmessageqt/__init__.py" line="3770"/>
         <source>You have already set an avatar for this address. Do you really want to overwrite it?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="4206"/>
+        <location filename="../bitmessageqt/__init__.py" line="4172"/>
         <source>Start-on-login not yet supported on your OS.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="4199"/>
+        <location filename="../bitmessageqt/__init__.py" line="4165"/>
         <source>Minimize-to-tray not yet supported on your OS.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="4202"/>
+        <location filename="../bitmessageqt/__init__.py" line="4168"/>
         <source>Tray notifications not yet supported on your OS.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="4373"/>
+        <location filename="../bitmessageqt/__init__.py" line="4339"/>
         <source>Testing...</source>
         <translation>...</translation>
     </message>
@@ -922,37 +922,37 @@ Are you sure you want to delete the channel?</source>
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="45"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="35"/>
         <source>The address should start with &apos;&apos;BM-&apos;&apos;</source>
         <translation>&quot;BM-&quot;</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="50"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="40"/>
         <source>The address is not typed or copied correctly (the checksum failed).</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="56"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="46"/>
         <source>The version number of this address is higher than this software can support. Please upgrade Bitmessage.</source>
         <translation> </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="62"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="52"/>
         <source>The address contains invalid characters.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="67"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="57"/>
         <source>Some data encoded in the address is too short.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="72"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="62"/>
         <source>Some data encoded in the address is too long.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="77"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="67"/>
         <source>Some data encoded in the address is malformed.</source>
         <translation>.</translation>
     </message>
@@ -962,12 +962,12 @@ Are you sure you want to delete the channel?</source>
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="188"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="171"/>
         <source>Address is an old type. We cannot display its past broadcasts.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="203"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="186"/>
         <source>There are no recent broadcasts from this address to display.</source>
         <translation></translation>
     </message>
@@ -1162,12 +1162,12 @@ Are you sure you want to delete the channel?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/foldertree.py" line="224"/>
+        <location filename="../bitmessageqt/foldertree.py" line="206"/>
         <source>All accounts</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/messageview.py" line="56"/>
+        <location filename="../bitmessageqt/messageview.py" line="47"/>
         <source>Zoom level %1%</source>
         <translation>1</translation>
     </message>
@@ -1187,42 +1187,42 @@ Are you sure you want to delete the channel?</source>
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1774"/>
+        <location filename="../bitmessageqt/__init__.py" line="1786"/>
         <source>New version of PyBitmessage is available: %1. Download it from https://github.com/Bitmessage/PyBitmessage/releases/latest</source>
         <translation>PyBitmessage: %1. https://github.com/Bitmessage/PyBitmessage/releases/latest</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2817"/>
+        <location filename="../bitmessageqt/__init__.py" line="2788"/>
         <source>Waiting for PoW to finish... %1%</source>
         <translation>PoW...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2826"/>
+        <location filename="../bitmessageqt/__init__.py" line="2798"/>
         <source>Shutting down Pybitmessage... %1%</source>
         <translation>Pybitmessage ...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2845"/>
+        <location filename="../bitmessageqt/__init__.py" line="2817"/>
         <source>Waiting for objects to be sent... %1%</source>
         <translation>...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2862"/>
+        <location filename="../bitmessageqt/__init__.py" line="2835"/>
         <source>Saving settings... %1%</source>
         <translation>...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2875"/>
+        <location filename="../bitmessageqt/__init__.py" line="2848"/>
         <source>Shutting down core... %1%</source>
         <translation>...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2881"/>
+        <location filename="../bitmessageqt/__init__.py" line="2854"/>
         <source>Stopping notifications... %1%</source>
         <translation>...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2885"/>
+        <location filename="../bitmessageqt/__init__.py" line="2858"/>
         <source>Shutdown imminent... %1%</source>
         <translation>...%1%</translation>
     </message>
@@ -1232,17 +1232,17 @@ Are you sure you want to delete the channel?</source>
         <translation><numerusform>%n </numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/__init__.py" line="825"/>
+        <location filename="../bitmessageqt/__init__.py" line="837"/>
         <source>%n day(s)</source>
         <translation><numerusform>%n </numerusform></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2783"/>
+        <location filename="../bitmessageqt/__init__.py" line="2756"/>
         <source>Shutting down PyBitmessage... %1%</source>
         <translation>PyBitmessage...%1%</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1144"/>
+        <location filename="../bitmessageqt/__init__.py" line="1156"/>
         <source>Sent</source>
         <translation></translation>
     </message>
@@ -1287,42 +1287,42 @@ Are you sure you want to delete the channel?</source>
         <translation>: . .</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="1058"/>
+        <location filename="../class_singleWorker.py" line="1060"/>
         <source>Error! Could not find sender address (your address) in the keys.dat file.</source>
         <translation>! keys.dat  ( ).</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="579"/>
+        <location filename="../class_singleWorker.py" line="580"/>
         <source>Doing work necessary to send broadcast...</source>
         <translation>, ...</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="612"/>
+        <location filename="../class_singleWorker.py" line="613"/>
         <source>Broadcast sent on %1</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="722"/>
+        <location filename="../class_singleWorker.py" line="721"/>
         <source>Encryption key was requested earlier.</source>
         <translation>.</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="794"/>
+        <location filename="../class_singleWorker.py" line="795"/>
         <source>Sending a request for the recipient&apos;s encryption key.</source>
         <translation>.</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="819"/>
+        <location filename="../class_singleWorker.py" line="820"/>
         <source>Looking up the receiver&apos;s public key</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="877"/>
+        <location filename="../class_singleWorker.py" line="878"/>
         <source>Problem: Destination is a mobile device who requests that the destination be included in the message but this is disallowed in your settings.  %1</source>
         <translation> %1</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="908"/>
+        <location filename="../class_singleWorker.py" line="909"/>
         <source>Doing work necessary to send message.
 There is no required difficulty for version 2 addresses like this.</source>
         <translation>, . 
@@ -1336,47 +1336,47 @@ Receiver&apos;s required difficulty: %1 and %2</source>
 : %1%2</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="986"/>
+        <location filename="../class_singleWorker.py" line="984"/>
         <source>Problem: The work demanded by the recipient (%1 and %2) is more difficult than you are willing to do. %3</source>
         <translation>: (%1%2). %3</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="1010"/>
+        <location filename="../class_singleWorker.py" line="1012"/>
         <source>Problem: You are trying to send a message to yourself or a chan but your encryption key could not be found in the keys.dat file. Could not encrypt message. %1</source>
         <translation>: , keys.dat. . %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1045"/>
+        <location filename="../bitmessageqt/__init__.py" line="1057"/>
         <source>Doing work necessary to send message.</source>
         <translation>, .</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="1214"/>
+        <location filename="../class_singleWorker.py" line="1218"/>
         <source>Message sent. Waiting for acknowledgement. Sent on %1</source>
         <translation>. . %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1033"/>
+        <location filename="../bitmessageqt/__init__.py" line="1045"/>
         <source>Doing work necessary to request encryption key.</source>
         <translation>.</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="1376"/>
+        <location filename="../class_singleWorker.py" line="1380"/>
         <source>Broadcasting the public key request. This program will auto-retry if they are offline.</source>
         <translation>. , .</translation>
     </message>
     <message>
-        <location filename="../class_singleWorker.py" line="1383"/>
+        <location filename="../class_singleWorker.py" line="1387"/>
         <source>Sending public key request. Waiting for reply. Requested at %1</source>
         <translation>. . %1</translation>
     </message>
     <message>
-        <location filename="../upnp.py" line="267"/>
+        <location filename="../upnp.py" line="235"/>
         <source>UPnP port mapping established on port %1</source>
         <translation>UPnP%1</translation>
     </message>
     <message>
-        <location filename="../upnp.py" line="293"/>
+        <location filename="../upnp.py" line="264"/>
         <source>UPnP port mapping removed</source>
         <translation>UPnP</translation>
     </message>
@@ -1386,87 +1386,87 @@ Receiver&apos;s required difficulty: %1 and %2</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2636"/>
+        <location filename="../bitmessageqt/__init__.py" line="2648"/>
         <source>Are you sure you would like to mark all messages read?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1054"/>
+        <location filename="../bitmessageqt/__init__.py" line="1066"/>
         <source>Doing work necessary to send broadcast.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2718"/>
+        <location filename="../bitmessageqt/__init__.py" line="2724"/>
         <source>Proof of work pending</source>
         <translation></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/__init__.py" line="2718"/>
+        <location filename="../bitmessageqt/__init__.py" line="2724"/>
         <source>%n object(s) pending proof of work</source>
         <translation><numerusform>%n </numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/__init__.py" line="2718"/>
+        <location filename="../bitmessageqt/__init__.py" line="2724"/>
         <source>%n object(s) waiting to be distributed</source>
         <translation><numerusform>%n </numerusform></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2718"/>
+        <location filename="../bitmessageqt/__init__.py" line="2724"/>
         <source>Wait until these tasks finish?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="119"/>
+        <location filename="../namecoin.py" line="115"/>
         <source>The name %1 was not found.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="130"/>
+        <location filename="../namecoin.py" line="124"/>
         <source>The namecoin query failed (%1)</source>
         <translation>(%1)</translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="134"/>
-        <source>Unknown namecoin interface type: %1</source>
-        <translation> Namecoin  %1</translation>
-    </message>
-    <message>
-        <location filename="../namecoin.py" line="139"/>
+        <location filename="../namecoin.py" line="127"/>
         <source>The namecoin query failed.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="156"/>
+        <location filename="../namecoin.py" line="133"/>
+        <source>The name %1 has no valid JSON data.</source>
+        <translation>%1JSON</translation>
+    </message>
+    <message>
+        <location filename="../namecoin.py" line="141"/>
         <source>The name %1 has no associated Bitmessage address.</source>
         <translation> %1</translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="185"/>
+        <location filename="../namecoin.py" line="171"/>
         <source>Success!  Namecoind version %1 running.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="196"/>
+        <location filename="../namecoin.py" line="182"/>
         <source>Success!  NMControll is up and running.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="199"/>
+        <location filename="../namecoin.py" line="185"/>
         <source>Couldn&apos;t understand NMControl.</source>
         <translation> NMControl</translation>
     </message>
     <message>
-        <location filename="../namecoin.py" line="209"/>
+        <location filename="../namecoin.py" line="195"/>
         <source>The connection to namecoin failed.</source>
         <translation> Namecoin </translation>
     </message>
     <message>
-        <location filename="../proofofwork.py" line="132"/>
+        <location filename="../proofofwork.py" line="120"/>
         <source>Your GPU(s) did not calculate correctly, disabling OpenCL. Please report to the developers.</source>
         <translation>GPUOpenGL</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3828"/>
+        <location filename="../bitmessageqt/__init__.py" line="3810"/>
         <source>Set notification sound...</source>
         <translation>...</translation>
     </message>
@@ -1485,137 +1485,117 @@ Receiver&apos;s required difficulty: %1 and %2</source>
 *</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="816"/>
+        <location filename="../bitmessageqt/__init__.py" line="828"/>
         <source>not recommended for chans</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1209"/>
+        <location filename="../bitmessageqt/__init__.py" line="1221"/>
         <source>Quiet Mode</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1601"/>
+        <location filename="../bitmessageqt/__init__.py" line="1613"/>
         <source>Problems connecting? Try enabling UPnP in the Network Settings</source>
         <translation>UPnP</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1928"/>
+        <location filename="../bitmessageqt/__init__.py" line="1940"/>
         <source>You are trying to send an email instead of a bitmessage. This requires registering with a gateway. Attempt to register?</source>
         <translation> Bitmessage </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1960"/>
+        <location filename="../bitmessageqt/__init__.py" line="1972"/>
         <source>Error: Bitmessage addresses start with BM-   Please check the recipient address %1</source>
         <translation>BitmessageBM-%1.</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1966"/>
+        <location filename="../bitmessageqt/__init__.py" line="1978"/>
         <source>Error: The recipient address %1 is not typed or copied correctly. Please check it.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1972"/>
+        <location filename="../bitmessageqt/__init__.py" line="1984"/>
         <source>Error: The recipient address %1 contains invalid characters. Please check it.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1978"/>
+        <location filename="../bitmessageqt/__init__.py" line="1990"/>
         <source>Error: The version of the recipient address %1 is too high. Either you need to upgrade your Bitmessage software or your acquaintance is being clever.</source>
         <translation> %1  </translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1986"/>
+        <location filename="../bitmessageqt/__init__.py" line="1998"/>
         <source>Error: Some data encoded in the recipient address %1 is too short. There might be something wrong with the software of your acquaintance.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="1994"/>
+        <location filename="../bitmessageqt/__init__.py" line="2006"/>
         <source>Error: Some data encoded in the recipient address %1 is too long. There might be something wrong with the software of your acquaintance.</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2002"/>
+        <location filename="../bitmessageqt/__init__.py" line="2014"/>
         <source>Error: Some data encoded in the recipient address %1 is malformed. There might be something wrong with the software of your acquaintance.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2010"/>
+        <location filename="../bitmessageqt/__init__.py" line="2022"/>
         <source>Error: Something is wrong with the recipient address %1.</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2159"/>
+        <location filename="../bitmessageqt/__init__.py" line="2172"/>
         <source>Error: %1</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2276"/>
+        <location filename="../bitmessageqt/__init__.py" line="2289"/>
         <source>From %1</source>
         <translation> %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2680"/>
-        <source>Disconnecting</source>
-        <translation></translation>
-    </message>
-    <message>
-        <location filename="../bitmessageqt/__init__.py" line="2680"/>
-        <source>Connecting</source>
-        <translation></translation>
-    </message>
-    <message>
-        <location filename="../bitmessageqt/__init__.py" line="2680"/>
-        <source>Bitmessage will now drop all connectins. Are you sure?</source>
-        <translation type="unfinished"/>
-    </message>
-    <message>
-        <location filename="../bitmessageqt/__init__.py" line="2680"/>
-        <source>Bitmessage will now start connecting to network. Are you sure?</source>
-        <translation type="unfinished"/>
-    </message>
-    <message>
-        <location filename="../bitmessageqt/__init__.py" line="2742"/>
+        <location filename="../bitmessageqt/__init__.py" line="2735"/>
         <source>Synchronisation pending</source>
         <translation></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/__init__.py" line="2742"/>
+        <location filename="../bitmessageqt/__init__.py" line="2735"/>
         <source>Bitmessage hasn&apos;t synchronised with the network, %n object(s) to be downloaded. If you quit now, it may cause delivery delays. Wait until the synchronisation finishes?</source>
-        <translation><numerusform>Bitmessage%n </numerusform></translation>
+        <translation type="unfinished"><numerusform></numerusform></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2763"/>
+        <location filename="../bitmessageqt/__init__.py" line="2745"/>
         <source>Not connected</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2763"/>
+        <location filename="../bitmessageqt/__init__.py" line="2745"/>
         <source>Bitmessage isn&apos;t connected to the network. If you quit now, it may cause delivery delays. Wait until connected and the synchronisation finishes?</source>
-        <translation>Bitmessage</translation>
+        <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2787"/>
+        <location filename="../bitmessageqt/__init__.py" line="2760"/>
         <source>Waiting for network connection...</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="2799"/>
+        <location filename="../bitmessageqt/__init__.py" line="2770"/>
         <source>Waiting for finishing synchronisation...</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="3846"/>
+        <location filename="../bitmessageqt/__init__.py" line="3828"/>
         <source>You have already set a notification sound for this address book entry. Do you really want to overwrite it?</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/__init__.py" line="4067"/>
+        <location filename="../bitmessageqt/__init__.py" line="4049"/>
         <source>Error occurred: could not load message from disk.</source>
         <translation></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/address_dialogs.py" line="211"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="194"/>
         <source>Display the %n recent broadcast(s) from this address.</source>
         <translation><numerusform> %n </numerusform></translation>
     </message>
@@ -1635,22 +1615,22 @@ Receiver&apos;s required difficulty: %1 and %2</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/foldertree.py" line="16"/>
+        <location filename="../bitmessageqt/foldertree.py" line="10"/>
         <source>inbox</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/foldertree.py" line="17"/>
+        <location filename="../bitmessageqt/foldertree.py" line="11"/>
         <source>new</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/foldertree.py" line="18"/>
+        <location filename="../bitmessageqt/foldertree.py" line="12"/>
         <source>sent</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/foldertree.py" line="19"/>
+        <location filename="../bitmessageqt/foldertree.py" line="13"/>
         <source>trash</source>
         <translation></translation>
     </message>
@@ -1658,22 +1638,22 @@ Receiver&apos;s required difficulty: %1 and %2</source>
 <context>
     <name>MessageView</name>
     <message>
-        <location filename="../bitmessageqt/messageview.py" line="84"/>
+        <location filename="../bitmessageqt/messageview.py" line="72"/>
         <source>Follow external link</source>
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/messageview.py" line="84"/>
+        <location filename="../bitmessageqt/messageview.py" line="72"/>
         <source>The link &quot;%1&quot; will open in a browser. It may be a security risk, it could de-anonymise you or download malicious data. Are you sure?</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/messageview.py" line="134"/>
+        <location filename="../bitmessageqt/messageview.py" line="117"/>
         <source>HTML detected, click here to display</source>
         <translation>HTML</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/messageview.py" line="146"/>
+        <location filename="../bitmessageqt/messageview.py" line="126"/>
         <source>Click here to disable HTML</source>
         <translation>HTML</translation>
     </message>
@@ -1681,14 +1661,14 @@ Receiver&apos;s required difficulty: %1 and %2</source>
 <context>
     <name>MsgDecode</name>
     <message>
-        <location filename="../helper_msgcoding.py" line="84"/>
+        <location filename="../helper_msgcoding.py" line="81"/>
         <source>The message has an unknown encoding.
 Perhaps you should upgrade Bitmessage.</source>
         <translation>
 Bitmessage</translation>
     </message>
     <message>
-        <location filename="../helper_msgcoding.py" line="88"/>
+        <location filename="../helper_msgcoding.py" line="82"/>
         <source>Unknown encoding</source>
         <translation></translation>
     </message>
@@ -1843,7 +1823,7 @@ The &apos;Random Number&apos; option is selected by default but deterministic ad
         <translation></translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/address_dialogs.py" line="249"/>
+        <location filename="../bitmessageqt/address_dialogs.py" line="230"/>
         <source>This is a chan address. You cannot use it as a pseudo-mailing list.</source>
         <translation></translation>
     </message>
@@ -2051,27 +2031,27 @@ The &apos;Random Number&apos; option is selected by default but deterministic ad
         <translation type="unfinished"/>
     </message>
     <message>
-        <location filename="../bitmessageqt/networkstatus.py" line="242"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="171"/>
         <source>Since startup on %1</source>
         <translation>%1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/networkstatus.py" line="140"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="90"/>
         <source>Down: %1/s  Total: %2</source>
         <translation>: %1/ : %2</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/networkstatus.py" line="146"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="92"/>
         <source>Up: %1/s  Total: %2</source>
         <translation>: %1/ : %2</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/networkstatus.py" line="219"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="153"/>
         <source>Total Connections: %1</source>
         <translation>: %1</translation>
     </message>
     <message>
-        <location filename="../bitmessageqt/networkstatus.py" line="234"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="163"/>
         <source>Inventory lookups per second: %1</source>
         <translation>: %1</translation>
     </message>
@@ -2091,27 +2071,27 @@ The &apos;Random Number&apos; option is selected by default but deterministic ad
         <translation></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/networkstatus.py" line="70"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="57"/>
         <source>byte(s)</source>
         <translation><numerusform></numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/networkstatus.py" line="93"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="68"/>
         <source>Object(s) to be synced: %n</source>
         <translation><numerusform>: %n</numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/networkstatus.py" line="105"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="72"/>
         <source>Processed %n person-to-person message(s).</source>
         <translation><numerusform>%n.</numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/networkstatus.py" line="116"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="77"/>
         <source>Processed %n broadcast message(s).</source>
         <translation><numerusform>%n.</numerusform></translation>
     </message>
     <message numerus="yes">
-        <location filename="../bitmessageqt/networkstatus.py" line="127"/>
+        <location filename="../bitmessageqt/networkstatus.py" line="82"/>
         <source>Processed %n public key(s).</source>
         <translation><numerusform>%n.</numerusform></translation>
     </message>
@@ -2255,17 +2235,17 @@ The &apos;Random Number&apos; option is selected by default but deterministic ad
 <context>
     <name>proofofwork</name>
     <message>
-        <location filename="../proofofwork.py" line="196"/>
+        <location filename="../proofofwork.py" line="163"/>
         <source>C PoW module built successfully.</source>
         <translation>C PoW</translation>
     </message>
     <message>
-        <location filename="../proofofwork.py" line="199"/>
+        <location filename="../proofofwork.py" line="165"/>
         <source>Failed to build C PoW module. Please build it manually.</source>
         <translation>C PoW</translation>
     </message>
     <message>
-        <location filename="../proofofwork.py" line="211"/>
+        <location filename="../proofofwork.py" line="167"/>
         <source>C PoW module unavailable. Please build it.</source>
         <translation>C PoW</translation>
     </message>
